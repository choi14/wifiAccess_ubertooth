
usb_test.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00001e40  00004000  00004000  00004000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .persistent   00000020  10000000  10000000  00020000  2**0
                  ALLOC
  2 .data         000004da  10000020  00005e40  00010020  2**3
                  CONTENTS, ALLOC, LOAD, DATA
  3 .bss          00000219  100004fc  0000631a  000104fc  2**2
                  ALLOC
  4 .ARM.attributes 00000029  00000000  00000000  000104fa  2**0
                  CONTENTS, READONLY
  5 .comment      00000070  00000000  00000000  00010523  2**0
                  CONTENTS, READONLY
  6 .debug_info   00003e2c  00000000  00000000  00010593  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000013d1  00000000  00000000  000143bf  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_loc    00000413  00000000  00000000  00015790  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_aranges 000004a0  00000000  00000000  00015ba8  2**3
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_ranges 00000390  00000000  00000000  00016048  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_line   00001647  00000000  00000000  000163d8  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_str    000015cf  00000000  00000000  00017a1f  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_frame  00000efc  00000000  00000000  00018ff0  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00004000 <_NVIC_Handler_Functions>:
    4000:	e0 3f 00 10 05 47 00 00 71 47 00 00 71 47 00 00     .?...G..qG..qG..
    4010:	71 47 00 00 71 47 00 00 71 47 00 00 00 00 00 00     qG..qG..qG......
    4020:	00 00 00 00 00 00 00 00 00 00 00 00 71 47 00 00     ............qG..
    4030:	71 47 00 00 00 00 00 00 71 47 00 00 71 47 00 00     qG......qG..qG..
    4040:	71 47 00 00 71 47 00 00 71 47 00 00 71 47 00 00     qG..qG..qG..qG..
    4050:	71 47 00 00 71 47 00 00 71 47 00 00 71 47 00 00     qG..qG..qG..qG..
    4060:	71 47 00 00 71 47 00 00 71 47 00 00 71 47 00 00     qG..qG..qG..qG..
    4070:	71 47 00 00 71 47 00 00 71 47 00 00 71 47 00 00     qG..qG..qG..qG..
    4080:	71 47 00 00 71 47 00 00 71 47 00 00 71 47 00 00     qG..qG..qG..qG..
    4090:	71 47 00 00 71 47 00 00 71 47 00 00 71 47 00 00     qG..qG..qG..qG..
    40a0:	55 45 00 00 71 47 00 00 71 47 00 00 71 47 00 00     UE..qG..qG..qG..
    40b0:	71 47 00 00 71 47 00 00 71 47 00 00 71 47 00 00     qG..qG..qG..qG..
    40c0:	71 47 00 00 71 47 00 00 71 47 00 00                 qG..qG..qG..

000040cc <deregister_tm_clones>:
    40cc:	4b04      	ldr	r3, [pc, #16]	; (40e0 <deregister_tm_clones+0x14>)
    40ce:	4805      	ldr	r0, [pc, #20]	; (40e4 <deregister_tm_clones+0x18>)
    40d0:	1a1b      	subs	r3, r3, r0
    40d2:	2b06      	cmp	r3, #6
    40d4:	d902      	bls.n	40dc <deregister_tm_clones+0x10>
    40d6:	4b04      	ldr	r3, [pc, #16]	; (40e8 <deregister_tm_clones+0x1c>)
    40d8:	b103      	cbz	r3, 40dc <deregister_tm_clones+0x10>
    40da:	4718      	bx	r3
    40dc:	4770      	bx	lr
    40de:	bf00      	nop
    40e0:	100004ff 	.word	0x100004ff
    40e4:	100004fc 	.word	0x100004fc
    40e8:	00000000 	.word	0x00000000

000040ec <register_tm_clones>:
    40ec:	4905      	ldr	r1, [pc, #20]	; (4104 <register_tm_clones+0x18>)
    40ee:	4806      	ldr	r0, [pc, #24]	; (4108 <register_tm_clones+0x1c>)
    40f0:	1a09      	subs	r1, r1, r0
    40f2:	1089      	asrs	r1, r1, #2
    40f4:	eb01 71d1 	add.w	r1, r1, r1, lsr #31
    40f8:	1049      	asrs	r1, r1, #1
    40fa:	d002      	beq.n	4102 <register_tm_clones+0x16>
    40fc:	4b03      	ldr	r3, [pc, #12]	; (410c <register_tm_clones+0x20>)
    40fe:	b103      	cbz	r3, 4102 <register_tm_clones+0x16>
    4100:	4718      	bx	r3
    4102:	4770      	bx	lr
    4104:	100004fc 	.word	0x100004fc
    4108:	100004fc 	.word	0x100004fc
    410c:	00000000 	.word	0x00000000

00004110 <__do_global_dtors_aux>:
    4110:	b510      	push	{r4, lr}
    4112:	4c06      	ldr	r4, [pc, #24]	; (412c <__do_global_dtors_aux+0x1c>)
    4114:	7823      	ldrb	r3, [r4, #0]
    4116:	b943      	cbnz	r3, 412a <__do_global_dtors_aux+0x1a>
    4118:	f7ff ffd8 	bl	40cc <deregister_tm_clones>
    411c:	4b04      	ldr	r3, [pc, #16]	; (4130 <__do_global_dtors_aux+0x20>)
    411e:	b113      	cbz	r3, 4126 <__do_global_dtors_aux+0x16>
    4120:	4804      	ldr	r0, [pc, #16]	; (4134 <__do_global_dtors_aux+0x24>)
    4122:	f3af 8000 	nop.w
    4126:	2301      	movs	r3, #1
    4128:	7023      	strb	r3, [r4, #0]
    412a:	bd10      	pop	{r4, pc}
    412c:	100004fc 	.word	0x100004fc
    4130:	00000000 	.word	0x00000000
    4134:	00005e18 	.word	0x00005e18

00004138 <frame_dummy>:
    4138:	b508      	push	{r3, lr}
    413a:	4b08      	ldr	r3, [pc, #32]	; (415c <frame_dummy+0x24>)
    413c:	b11b      	cbz	r3, 4146 <frame_dummy+0xe>
    413e:	4808      	ldr	r0, [pc, #32]	; (4160 <frame_dummy+0x28>)
    4140:	4908      	ldr	r1, [pc, #32]	; (4164 <frame_dummy+0x2c>)
    4142:	f3af 8000 	nop.w
    4146:	4808      	ldr	r0, [pc, #32]	; (4168 <frame_dummy+0x30>)
    4148:	6803      	ldr	r3, [r0, #0]
    414a:	b913      	cbnz	r3, 4152 <frame_dummy+0x1a>
    414c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    4150:	e7cc      	b.n	40ec <register_tm_clones>
    4152:	4b06      	ldr	r3, [pc, #24]	; (416c <frame_dummy+0x34>)
    4154:	2b00      	cmp	r3, #0
    4156:	d0f9      	beq.n	414c <frame_dummy+0x14>
    4158:	4798      	blx	r3
    415a:	e7f7      	b.n	414c <frame_dummy+0x14>
    415c:	00000000 	.word	0x00000000
    4160:	00005e18 	.word	0x00005e18
    4164:	10000500 	.word	0x10000500
    4168:	100004fc 	.word	0x100004fc
    416c:	00000000 	.word	0x00000000

00004170 <atexit>:
    4170:	4601      	mov	r1, r0
    4172:	2000      	movs	r0, #0
    4174:	4602      	mov	r2, r0
    4176:	4603      	mov	r3, r0
    4178:	f000 b83e 	b.w	41f8 <__register_exitproc>

0000417c <__libc_fini_array>:
    417c:	b538      	push	{r3, r4, r5, lr}
    417e:	4b08      	ldr	r3, [pc, #32]	; (41a0 <__libc_fini_array+0x24>)
    4180:	4d08      	ldr	r5, [pc, #32]	; (41a4 <__libc_fini_array+0x28>)
    4182:	1aed      	subs	r5, r5, r3
    4184:	10ac      	asrs	r4, r5, #2
    4186:	bf18      	it	ne
    4188:	18ed      	addne	r5, r5, r3
    418a:	d005      	beq.n	4198 <__libc_fini_array+0x1c>
    418c:	3c01      	subs	r4, #1
    418e:	f855 3d04 	ldr.w	r3, [r5, #-4]!
    4192:	4798      	blx	r3
    4194:	2c00      	cmp	r4, #0
    4196:	d1f9      	bne.n	418c <__libc_fini_array+0x10>
    4198:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    419c:	f001 be46 	b.w	5e2c <_fini>
    41a0:	00005e38 	.word	0x00005e38
    41a4:	00005e3c 	.word	0x00005e3c

000041a8 <__libc_init_array>:
    41a8:	b570      	push	{r4, r5, r6, lr}
    41aa:	4e0f      	ldr	r6, [pc, #60]	; (41e8 <__libc_init_array+0x40>)
    41ac:	4d0f      	ldr	r5, [pc, #60]	; (41ec <__libc_init_array+0x44>)
    41ae:	1b76      	subs	r6, r6, r5
    41b0:	10b6      	asrs	r6, r6, #2
    41b2:	bf18      	it	ne
    41b4:	2400      	movne	r4, #0
    41b6:	d005      	beq.n	41c4 <__libc_init_array+0x1c>
    41b8:	3401      	adds	r4, #1
    41ba:	f855 3b04 	ldr.w	r3, [r5], #4
    41be:	4798      	blx	r3
    41c0:	42a6      	cmp	r6, r4
    41c2:	d1f9      	bne.n	41b8 <__libc_init_array+0x10>
    41c4:	4e0a      	ldr	r6, [pc, #40]	; (41f0 <__libc_init_array+0x48>)
    41c6:	4d0b      	ldr	r5, [pc, #44]	; (41f4 <__libc_init_array+0x4c>)
    41c8:	f001 fe26 	bl	5e18 <_init>
    41cc:	1b76      	subs	r6, r6, r5
    41ce:	10b6      	asrs	r6, r6, #2
    41d0:	bf18      	it	ne
    41d2:	2400      	movne	r4, #0
    41d4:	d006      	beq.n	41e4 <__libc_init_array+0x3c>
    41d6:	3401      	adds	r4, #1
    41d8:	f855 3b04 	ldr.w	r3, [r5], #4
    41dc:	4798      	blx	r3
    41de:	42a6      	cmp	r6, r4
    41e0:	d1f9      	bne.n	41d6 <__libc_init_array+0x2e>
    41e2:	bd70      	pop	{r4, r5, r6, pc}
    41e4:	bd70      	pop	{r4, r5, r6, pc}
    41e6:	bf00      	nop
    41e8:	00005e24 	.word	0x00005e24
    41ec:	00005e24 	.word	0x00005e24
    41f0:	00005e2c 	.word	0x00005e2c
    41f4:	00005e24 	.word	0x00005e24

000041f8 <__register_exitproc>:
    41f8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    41fc:	4c25      	ldr	r4, [pc, #148]	; (4294 <__register_exitproc+0x9c>)
    41fe:	4606      	mov	r6, r0
    4200:	6825      	ldr	r5, [r4, #0]
    4202:	4688      	mov	r8, r1
    4204:	f8d5 4148 	ldr.w	r4, [r5, #328]	; 0x148
    4208:	4692      	mov	sl, r2
    420a:	4699      	mov	r9, r3
    420c:	b3c4      	cbz	r4, 4280 <__register_exitproc+0x88>
    420e:	6860      	ldr	r0, [r4, #4]
    4210:	281f      	cmp	r0, #31
    4212:	dc17      	bgt.n	4244 <__register_exitproc+0x4c>
    4214:	1c41      	adds	r1, r0, #1
    4216:	b176      	cbz	r6, 4236 <__register_exitproc+0x3e>
    4218:	eb04 0380 	add.w	r3, r4, r0, lsl #2
    421c:	f8c3 a088 	str.w	sl, [r3, #136]	; 0x88
    4220:	f8d4 5188 	ldr.w	r5, [r4, #392]	; 0x188
    4224:	2201      	movs	r2, #1
    4226:	4082      	lsls	r2, r0
    4228:	4315      	orrs	r5, r2
    422a:	2e02      	cmp	r6, #2
    422c:	f8c4 5188 	str.w	r5, [r4, #392]	; 0x188
    4230:	f8c3 9108 	str.w	r9, [r3, #264]	; 0x108
    4234:	d01e      	beq.n	4274 <__register_exitproc+0x7c>
    4236:	1c83      	adds	r3, r0, #2
    4238:	6061      	str	r1, [r4, #4]
    423a:	2000      	movs	r0, #0
    423c:	f844 8023 	str.w	r8, [r4, r3, lsl #2]
    4240:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    4244:	4b14      	ldr	r3, [pc, #80]	; (4298 <__register_exitproc+0xa0>)
    4246:	b303      	cbz	r3, 428a <__register_exitproc+0x92>
    4248:	f44f 70c8 	mov.w	r0, #400	; 0x190
    424c:	f3af 8000 	nop.w
    4250:	4604      	mov	r4, r0
    4252:	b1d0      	cbz	r0, 428a <__register_exitproc+0x92>
    4254:	f8d5 3148 	ldr.w	r3, [r5, #328]	; 0x148
    4258:	2700      	movs	r7, #0
    425a:	e884 0088 	stmia.w	r4, {r3, r7}
    425e:	4638      	mov	r0, r7
    4260:	f8c5 4148 	str.w	r4, [r5, #328]	; 0x148
    4264:	2101      	movs	r1, #1
    4266:	f8c4 7188 	str.w	r7, [r4, #392]	; 0x188
    426a:	f8c4 718c 	str.w	r7, [r4, #396]	; 0x18c
    426e:	2e00      	cmp	r6, #0
    4270:	d0e1      	beq.n	4236 <__register_exitproc+0x3e>
    4272:	e7d1      	b.n	4218 <__register_exitproc+0x20>
    4274:	f8d4 318c 	ldr.w	r3, [r4, #396]	; 0x18c
    4278:	431a      	orrs	r2, r3
    427a:	f8c4 218c 	str.w	r2, [r4, #396]	; 0x18c
    427e:	e7da      	b.n	4236 <__register_exitproc+0x3e>
    4280:	f505 74a6 	add.w	r4, r5, #332	; 0x14c
    4284:	f8c5 4148 	str.w	r4, [r5, #328]	; 0x148
    4288:	e7c1      	b.n	420e <__register_exitproc+0x16>
    428a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    428e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    4292:	bf00      	nop
    4294:	00005d18 	.word	0x00005d18
    4298:	00000000 	.word	0x00000000

0000429c <register_fini>:
    429c:	4b02      	ldr	r3, [pc, #8]	; (42a8 <register_fini+0xc>)
    429e:	b113      	cbz	r3, 42a6 <register_fini+0xa>
    42a0:	4802      	ldr	r0, [pc, #8]	; (42ac <register_fini+0x10>)
    42a2:	f7ff bf65 	b.w	4170 <atexit>
    42a6:	4770      	bx	lr
    42a8:	00000000 	.word	0x00000000
    42ac:	0000417d 	.word	0x0000417d

000042b0 <main>:

#include "ubertooth.h"
#include "usb_serial.h"

int main()
{
    42b0:	b580      	push	{r7, lr}
    42b2:	b082      	sub	sp, #8
    42b4:	af00      	add	r7, sp, #0
	int c;

	ubertooth_init();
    42b6:	f000 fb43 	bl	4940 <ubertooth_init>
	usb_serial_init();
    42ba:	f000 f951 	bl	4560 <usb_serial_init>
	/*
	 * for each character received over USB serial connection, echo the
	 * character back over USB serial and toggle USRLED
	 */
	while (1) {
		c = VCOM_getchar();
    42be:	f000 f933 	bl	4528 <VCOM_getchar>
    42c2:	6078      	str	r0, [r7, #4]
		if (c != EOF) {
    42c4:	687b      	ldr	r3, [r7, #4]
    42c6:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
    42ca:	d00f      	beq.n	42ec <main+0x3c>
			/* toggle USRLED */
			if (USRLED)
    42cc:	4b08      	ldr	r3, [pc, #32]	; (42f0 <main+0x40>)
    42ce:	681b      	ldr	r3, [r3, #0]
    42d0:	f003 0302 	and.w	r3, r3, #2
    42d4:	2b00      	cmp	r3, #0
    42d6:	d003      	beq.n	42e0 <main+0x30>
				USRLED_CLR;
    42d8:	4b06      	ldr	r3, [pc, #24]	; (42f4 <main+0x44>)
    42da:	2202      	movs	r2, #2
    42dc:	601a      	str	r2, [r3, #0]
    42de:	e002      	b.n	42e6 <main+0x36>
			else
				USRLED_SET;
    42e0:	4b05      	ldr	r3, [pc, #20]	; (42f8 <main+0x48>)
    42e2:	2202      	movs	r2, #2
    42e4:	601a      	str	r2, [r3, #0]
			VCOM_putchar(c);
    42e6:	6878      	ldr	r0, [r7, #4]
    42e8:	f000 f906 	bl	44f8 <VCOM_putchar>
		}
	}
    42ec:	e7e7      	b.n	42be <main+0xe>
    42ee:	bf00      	nop
    42f0:	2009c034 	.word	0x2009c034
    42f4:	2009c03c 	.word	0x2009c03c
    42f8:	2009c038 	.word	0x2009c038

000042fc <HandleClassRequest>:
	@param [in] pSetup
	@param [out] piLen
	@param [out] ppbData
 */
static BOOL HandleClassRequest(TSetupPacket *pSetup, int *piLen, U8 **ppbData)
{
    42fc:	b580      	push	{r7, lr}
    42fe:	b084      	sub	sp, #16
    4300:	af00      	add	r7, sp, #0
    4302:	60f8      	str	r0, [r7, #12]
    4304:	60b9      	str	r1, [r7, #8]
    4306:	607a      	str	r2, [r7, #4]
	switch (pSetup->bRequest) {
    4308:	68fb      	ldr	r3, [r7, #12]
    430a:	785b      	ldrb	r3, [r3, #1]
    430c:	2b21      	cmp	r3, #33	; 0x21
    430e:	d00e      	beq.n	432e <HandleClassRequest+0x32>
    4310:	2b22      	cmp	r3, #34	; 0x22
    4312:	d015      	beq.n	4340 <HandleClassRequest+0x44>
    4314:	2b20      	cmp	r3, #32
    4316:	d111      	bne.n	433c <HandleClassRequest+0x40>

	// set line coding
	case SET_LINE_CODING:
		memcpy((U8 *)&LineCoding, *ppbData, 7);
    4318:	687b      	ldr	r3, [r7, #4]
    431a:	681b      	ldr	r3, [r3, #0]
    431c:	480b      	ldr	r0, [pc, #44]	; (434c <HandleClassRequest+0x50>)
    431e:	4619      	mov	r1, r3
    4320:	2207      	movs	r2, #7
    4322:	f001 fc81 	bl	5c28 <memcpy>
		*piLen = 7;
    4326:	68bb      	ldr	r3, [r7, #8]
    4328:	2207      	movs	r2, #7
    432a:	601a      	str	r2, [r3, #0]
		break;
    432c:	e009      	b.n	4342 <HandleClassRequest+0x46>

	// get line coding
	case GET_LINE_CODING:
		*ppbData = (U8 *)&LineCoding;
    432e:	687b      	ldr	r3, [r7, #4]
    4330:	4a06      	ldr	r2, [pc, #24]	; (434c <HandleClassRequest+0x50>)
    4332:	601a      	str	r2, [r3, #0]
		*piLen = 7;
    4334:	68bb      	ldr	r3, [r7, #8]
    4336:	2207      	movs	r2, #7
    4338:	601a      	str	r2, [r3, #0]
		break;
    433a:	e002      	b.n	4342 <HandleClassRequest+0x46>
	// set control line state
	case SET_CONTROL_LINE_STATE:
		break;

	default:
		return FALSE;
    433c:	2300      	movs	r3, #0
    433e:	e001      	b.n	4344 <HandleClassRequest+0x48>
		*piLen = 7;
		break;

	// set control line state
	case SET_CONTROL_LINE_STATE:
		break;
    4340:	bf00      	nop

	default:
		return FALSE;
	}
	return TRUE;
    4342:	2301      	movs	r3, #1
}
    4344:	4618      	mov	r0, r3
    4346:	3710      	adds	r7, #16
    4348:	46bd      	mov	sp, r7
    434a:	bd80      	pop	{r7, pc}
    434c:	1000044c 	.word	0x1000044c

00004350 <BulkOut>:
		
	@param [in] bEP
	@param [in] bEPStatus
 */
static void BulkOut(U8 bEP, U8 bEPStatus)
{
    4350:	b580      	push	{r7, lr}
    4352:	b084      	sub	sp, #16
    4354:	af00      	add	r7, sp, #0
    4356:	4603      	mov	r3, r0
    4358:	460a      	mov	r2, r1
    435a:	71fb      	strb	r3, [r7, #7]
    435c:	4613      	mov	r3, r2
    435e:	71bb      	strb	r3, [r7, #6]
	int i, iLen;

	if (fifo_free(&rxfifo) < MAX_PACKET_SIZE) {
    4360:	4813      	ldr	r0, [pc, #76]	; (43b0 <BulkOut+0x60>)
    4362:	f000 f9c1 	bl	46e8 <fifo_free>
    4366:	4603      	mov	r3, r0
    4368:	2b3f      	cmp	r3, #63	; 0x3f
    436a:	dc00      	bgt.n	436e <BulkOut+0x1e>
		// may not fit into fifo
		return;
    436c:	e01c      	b.n	43a8 <BulkOut+0x58>
	}

	// get data from USB into intermediate buffer
	iLen = USBHwEPRead(bEP, abBulkBuf, sizeof(abBulkBuf));
    436e:	79fb      	ldrb	r3, [r7, #7]
    4370:	4618      	mov	r0, r3
    4372:	4910      	ldr	r1, [pc, #64]	; (43b4 <BulkOut+0x64>)
    4374:	2240      	movs	r2, #64	; 0x40
    4376:	f000 fff9 	bl	536c <USBHwEPRead>
    437a:	60b8      	str	r0, [r7, #8]
	for (i = 0; i < iLen; i++) {
    437c:	2300      	movs	r3, #0
    437e:	60fb      	str	r3, [r7, #12]
    4380:	e00e      	b.n	43a0 <BulkOut+0x50>
		// put into FIFO
		if (!fifo_put(&rxfifo, abBulkBuf[i])) {
    4382:	4a0c      	ldr	r2, [pc, #48]	; (43b4 <BulkOut+0x64>)
    4384:	68fb      	ldr	r3, [r7, #12]
    4386:	4413      	add	r3, r2
    4388:	781b      	ldrb	r3, [r3, #0]
    438a:	4809      	ldr	r0, [pc, #36]	; (43b0 <BulkOut+0x60>)
    438c:	4619      	mov	r1, r3
    438e:	f000 f935 	bl	45fc <fifo_put>
    4392:	4603      	mov	r3, r0
    4394:	2b00      	cmp	r3, #0
    4396:	d100      	bne.n	439a <BulkOut+0x4a>
			// overflow... :(
			//ASSERT(FALSE);
			break;
    4398:	e006      	b.n	43a8 <BulkOut+0x58>
		return;
	}

	// get data from USB into intermediate buffer
	iLen = USBHwEPRead(bEP, abBulkBuf, sizeof(abBulkBuf));
	for (i = 0; i < iLen; i++) {
    439a:	68fb      	ldr	r3, [r7, #12]
    439c:	3301      	adds	r3, #1
    439e:	60fb      	str	r3, [r7, #12]
    43a0:	68fa      	ldr	r2, [r7, #12]
    43a2:	68bb      	ldr	r3, [r7, #8]
    43a4:	429a      	cmp	r2, r3
    43a6:	dbec      	blt.n	4382 <BulkOut+0x32>
			// overflow... :(
			//ASSERT(FALSE);
			break;
		}
	}
}
    43a8:	3710      	adds	r7, #16
    43aa:	46bd      	mov	sp, r7
    43ac:	bd80      	pop	{r7, pc}
    43ae:	bf00      	nop
    43b0:	10000674 	.word	0x10000674
    43b4:	10000518 	.word	0x10000518

000043b8 <SendNextBulkIn>:
		
	@param [in] bEP
	@param [in] bEPStatus
 */
static void SendNextBulkIn(U8 bEP, BOOL fFirstPacket)
{
    43b8:	b580      	push	{r7, lr}
    43ba:	b084      	sub	sp, #16
    43bc:	af00      	add	r7, sp, #0
    43be:	4603      	mov	r3, r0
    43c0:	6039      	str	r1, [r7, #0]
    43c2:	71fb      	strb	r3, [r7, #7]
	int iLen;

	// this transfer is done
	fBulkInBusy = FALSE;
    43c4:	4b1a      	ldr	r3, [pc, #104]	; (4430 <SendNextBulkIn+0x78>)
    43c6:	2200      	movs	r2, #0
    43c8:	601a      	str	r2, [r3, #0]
	
	// first packet?
	if (fFirstPacket) {
    43ca:	683b      	ldr	r3, [r7, #0]
    43cc:	2b00      	cmp	r3, #0
    43ce:	d002      	beq.n	43d6 <SendNextBulkIn+0x1e>
		fChainDone = FALSE;
    43d0:	4b18      	ldr	r3, [pc, #96]	; (4434 <SendNextBulkIn+0x7c>)
    43d2:	2200      	movs	r2, #0
    43d4:	601a      	str	r2, [r3, #0]
	}

	// last packet?
	if (fChainDone) {
    43d6:	4b17      	ldr	r3, [pc, #92]	; (4434 <SendNextBulkIn+0x7c>)
    43d8:	681b      	ldr	r3, [r3, #0]
    43da:	2b00      	cmp	r3, #0
    43dc:	d000      	beq.n	43e0 <SendNextBulkIn+0x28>
		return;
    43de:	e023      	b.n	4428 <SendNextBulkIn+0x70>
	}
	
	// get up to MAX_PACKET_SIZE bytes from transmit FIFO into intermediate buffer
	for (iLen = 0; iLen < MAX_PACKET_SIZE; iLen++) {
    43e0:	2300      	movs	r3, #0
    43e2:	60fb      	str	r3, [r7, #12]
    43e4:	e00d      	b.n	4402 <SendNextBulkIn+0x4a>
		if (!fifo_get(&txfifo, &abBulkBuf[iLen])) {
    43e6:	68fb      	ldr	r3, [r7, #12]
    43e8:	4a13      	ldr	r2, [pc, #76]	; (4438 <SendNextBulkIn+0x80>)
    43ea:	4413      	add	r3, r2
    43ec:	4813      	ldr	r0, [pc, #76]	; (443c <SendNextBulkIn+0x84>)
    43ee:	4619      	mov	r1, r3
    43f0:	f000 f930 	bl	4654 <fifo_get>
    43f4:	4603      	mov	r3, r0
    43f6:	2b00      	cmp	r3, #0
    43f8:	d100      	bne.n	43fc <SendNextBulkIn+0x44>
			break;
    43fa:	e005      	b.n	4408 <SendNextBulkIn+0x50>
	if (fChainDone) {
		return;
	}
	
	// get up to MAX_PACKET_SIZE bytes from transmit FIFO into intermediate buffer
	for (iLen = 0; iLen < MAX_PACKET_SIZE; iLen++) {
    43fc:	68fb      	ldr	r3, [r7, #12]
    43fe:	3301      	adds	r3, #1
    4400:	60fb      	str	r3, [r7, #12]
    4402:	68fb      	ldr	r3, [r7, #12]
    4404:	2b3f      	cmp	r3, #63	; 0x3f
    4406:	ddee      	ble.n	43e6 <SendNextBulkIn+0x2e>
			break;
		}
	}
	
	// send over USB
	USBHwEPWrite(bEP, abBulkBuf, iLen);
    4408:	68fb      	ldr	r3, [r7, #12]
    440a:	79fa      	ldrb	r2, [r7, #7]
    440c:	4610      	mov	r0, r2
    440e:	490a      	ldr	r1, [pc, #40]	; (4438 <SendNextBulkIn+0x80>)
    4410:	461a      	mov	r2, r3
    4412:	f000 ff5d 	bl	52d0 <USBHwEPWrite>
	fBulkInBusy = TRUE;
    4416:	4b06      	ldr	r3, [pc, #24]	; (4430 <SendNextBulkIn+0x78>)
    4418:	2201      	movs	r2, #1
    441a:	601a      	str	r2, [r3, #0]

	// was this a short packet?
	if (iLen < MAX_PACKET_SIZE) {
    441c:	68fb      	ldr	r3, [r7, #12]
    441e:	2b3f      	cmp	r3, #63	; 0x3f
    4420:	dc02      	bgt.n	4428 <SendNextBulkIn+0x70>
		fChainDone = TRUE;
    4422:	4b04      	ldr	r3, [pc, #16]	; (4434 <SendNextBulkIn+0x7c>)
    4424:	2201      	movs	r2, #1
    4426:	601a      	str	r2, [r3, #0]
	}
}
    4428:	3710      	adds	r7, #16
    442a:	46bd      	mov	sp, r7
    442c:	bd80      	pop	{r7, pc}
    442e:	bf00      	nop
    4430:	10000560 	.word	0x10000560
    4434:	10000564 	.word	0x10000564
    4438:	10000518 	.word	0x10000518
    443c:	10000668 	.word	0x10000668

00004440 <BulkIn>:
		
	@param [in] bEP
	@param [in] bEPStatus
 */
static void BulkIn(U8 bEP, U8 bEPStatus)
{
    4440:	b580      	push	{r7, lr}
    4442:	b082      	sub	sp, #8
    4444:	af00      	add	r7, sp, #0
    4446:	4603      	mov	r3, r0
    4448:	460a      	mov	r2, r1
    444a:	71fb      	strb	r3, [r7, #7]
    444c:	4613      	mov	r3, r2
    444e:	71bb      	strb	r3, [r7, #6]
	SendNextBulkIn(bEP, FALSE);
    4450:	79fb      	ldrb	r3, [r7, #7]
    4452:	4618      	mov	r0, r3
    4454:	2100      	movs	r1, #0
    4456:	f7ff ffaf 	bl	43b8 <SendNextBulkIn>
}
    445a:	3708      	adds	r7, #8
    445c:	46bd      	mov	sp, r7
    445e:	bd80      	pop	{r7, pc}

00004460 <USBFrameHandler>:
	packet shorter than the maximum packet size or a zero-length packet
	(as required by the windows usbser.sys driver).

 */
static void USBFrameHandler(U16 wFrame)
{
    4460:	b580      	push	{r7, lr}
    4462:	b082      	sub	sp, #8
    4464:	af00      	add	r7, sp, #0
    4466:	4603      	mov	r3, r0
    4468:	80fb      	strh	r3, [r7, #6]
	if (!fBulkInBusy && (fifo_avail(&txfifo) != 0)) {
    446a:	4b08      	ldr	r3, [pc, #32]	; (448c <USBFrameHandler+0x2c>)
    446c:	681b      	ldr	r3, [r3, #0]
    446e:	2b00      	cmp	r3, #0
    4470:	d109      	bne.n	4486 <USBFrameHandler+0x26>
    4472:	4807      	ldr	r0, [pc, #28]	; (4490 <USBFrameHandler+0x30>)
    4474:	f000 f91c 	bl	46b0 <fifo_avail>
    4478:	4603      	mov	r3, r0
    447a:	2b00      	cmp	r3, #0
    447c:	d003      	beq.n	4486 <USBFrameHandler+0x26>
		// send first packet
		SendNextBulkIn(BULK_IN_EP, TRUE);
    447e:	2082      	movs	r0, #130	; 0x82
    4480:	2101      	movs	r1, #1
    4482:	f7ff ff99 	bl	43b8 <SendNextBulkIn>
	}
}
    4486:	3708      	adds	r7, #8
    4488:	46bd      	mov	sp, r7
    448a:	bd80      	pop	{r7, pc}
    448c:	10000560 	.word	0x10000560
    4490:	10000668 	.word	0x10000668

00004494 <USBDevIntHandler>:
	USB device status handler
	
	Resets state machine when a USB reset is received.
 */
static void USBDevIntHandler(U8 bDevStatus)
{
    4494:	b480      	push	{r7}
    4496:	b083      	sub	sp, #12
    4498:	af00      	add	r7, sp, #0
    449a:	4603      	mov	r3, r0
    449c:	71fb      	strb	r3, [r7, #7]
	if ((bDevStatus & DEV_STATUS_RESET) != 0) {
    449e:	79fb      	ldrb	r3, [r7, #7]
    44a0:	f003 0310 	and.w	r3, r3, #16
    44a4:	2b00      	cmp	r3, #0
    44a6:	d002      	beq.n	44ae <USBDevIntHandler+0x1a>
		fBulkInBusy = FALSE;
    44a8:	4b03      	ldr	r3, [pc, #12]	; (44b8 <USBDevIntHandler+0x24>)
    44aa:	2200      	movs	r2, #0
    44ac:	601a      	str	r2, [r3, #0]
	}
}
    44ae:	370c      	adds	r7, #12
    44b0:	46bd      	mov	sp, r7
    44b2:	f85d 7b04 	ldr.w	r7, [sp], #4
    44b6:	4770      	bx	lr
    44b8:	10000560 	.word	0x10000560

000044bc <VCOM_init>:
/**
	Initialises the VCOM port.
	Call this function before using VCOM_putchar or VCOM_getchar
 */
void VCOM_init(void)
{
    44bc:	b580      	push	{r7, lr}
    44be:	af00      	add	r7, sp, #0
	fifo_init(&txfifo, txdata);
    44c0:	4807      	ldr	r0, [pc, #28]	; (44e0 <VCOM_init+0x24>)
    44c2:	4908      	ldr	r1, [pc, #32]	; (44e4 <VCOM_init+0x28>)
    44c4:	f000 f886 	bl	45d4 <fifo_init>
	fifo_init(&rxfifo, rxdata);
    44c8:	4807      	ldr	r0, [pc, #28]	; (44e8 <VCOM_init+0x2c>)
    44ca:	4908      	ldr	r1, [pc, #32]	; (44ec <VCOM_init+0x30>)
    44cc:	f000 f882 	bl	45d4 <fifo_init>
	fBulkInBusy = FALSE;
    44d0:	4b07      	ldr	r3, [pc, #28]	; (44f0 <VCOM_init+0x34>)
    44d2:	2200      	movs	r2, #0
    44d4:	601a      	str	r2, [r3, #0]
	fChainDone = TRUE;
    44d6:	4b07      	ldr	r3, [pc, #28]	; (44f4 <VCOM_init+0x38>)
    44d8:	2201      	movs	r2, #1
    44da:	601a      	str	r2, [r3, #0]
}
    44dc:	bd80      	pop	{r7, pc}
    44de:	bf00      	nop
    44e0:	10000668 	.word	0x10000668
    44e4:	10000568 	.word	0x10000568
    44e8:	10000674 	.word	0x10000674
    44ec:	100005e8 	.word	0x100005e8
    44f0:	10000560 	.word	0x10000560
    44f4:	10000564 	.word	0x10000564

000044f8 <VCOM_putchar>:
	
	@param [in] c character to write
	@returns character written, or EOF if character could not be written
 */
int VCOM_putchar(int c)
{
    44f8:	b580      	push	{r7, lr}
    44fa:	b082      	sub	sp, #8
    44fc:	af00      	add	r7, sp, #0
    44fe:	6078      	str	r0, [r7, #4]
	return fifo_put(&txfifo, c) ? c : EOF;
    4500:	687b      	ldr	r3, [r7, #4]
    4502:	b2db      	uxtb	r3, r3
    4504:	4807      	ldr	r0, [pc, #28]	; (4524 <VCOM_putchar+0x2c>)
    4506:	4619      	mov	r1, r3
    4508:	f000 f878 	bl	45fc <fifo_put>
    450c:	4603      	mov	r3, r0
    450e:	2b00      	cmp	r3, #0
    4510:	d001      	beq.n	4516 <VCOM_putchar+0x1e>
    4512:	687b      	ldr	r3, [r7, #4]
    4514:	e001      	b.n	451a <VCOM_putchar+0x22>
    4516:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
}
    451a:	4618      	mov	r0, r3
    451c:	3708      	adds	r7, #8
    451e:	46bd      	mov	sp, r7
    4520:	bd80      	pop	{r7, pc}
    4522:	bf00      	nop
    4524:	10000668 	.word	0x10000668

00004528 <VCOM_getchar>:
	Reads one character from VCOM port
	
	@returns character read, or EOF if character could not be read
 */
int VCOM_getchar(void)
{
    4528:	b580      	push	{r7, lr}
    452a:	b082      	sub	sp, #8
    452c:	af00      	add	r7, sp, #0
	U8 c;
	
	return fifo_get(&rxfifo, &c) ? c : EOF;
    452e:	1dfb      	adds	r3, r7, #7
    4530:	4807      	ldr	r0, [pc, #28]	; (4550 <VCOM_getchar+0x28>)
    4532:	4619      	mov	r1, r3
    4534:	f000 f88e 	bl	4654 <fifo_get>
    4538:	4603      	mov	r3, r0
    453a:	2b00      	cmp	r3, #0
    453c:	d001      	beq.n	4542 <VCOM_getchar+0x1a>
    453e:	79fb      	ldrb	r3, [r7, #7]
    4540:	e001      	b.n	4546 <VCOM_getchar+0x1e>
    4542:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
}
    4546:	4618      	mov	r0, r3
    4548:	3708      	adds	r7, #8
    454a:	46bd      	mov	sp, r7
    454c:	bd80      	pop	{r7, pc}
    454e:	bf00      	nop
    4550:	10000674 	.word	0x10000674

00004554 <USB_IRQHandler>:

void USB_IRQHandler()
{
    4554:	b580      	push	{r7, lr}
    4556:	af00      	add	r7, sp, #0
	USBHwISR();
    4558:	f000 ff80 	bl	545c <USBHwISR>
}
    455c:	bd80      	pop	{r7, pc}
    455e:	bf00      	nop

00004560 <usb_serial_init>:

void usb_serial_init()
{
    4560:	b580      	push	{r7, lr}
    4562:	af00      	add	r7, sp, #0
	// initialise stack
	USBInit();
    4564:	f000 fd00 	bl	4f68 <USBInit>

	// register descriptors
	USBRegisterDescriptors(abDescriptors);
    4568:	4812      	ldr	r0, [pc, #72]	; (45b4 <usb_serial_init+0x54>)
    456a:	f001 f939 	bl	57e0 <USBRegisterDescriptors>

	// register class request handler
	USBRegisterRequestHandler(REQTYPE_TYPE_CLASS, HandleClassRequest, abClassReqData);
    456e:	2001      	movs	r0, #1
    4570:	4911      	ldr	r1, [pc, #68]	; (45b8 <usb_serial_init+0x58>)
    4572:	4a12      	ldr	r2, [pc, #72]	; (45bc <usb_serial_init+0x5c>)
    4574:	f000 fcd4 	bl	4f20 <USBRegisterRequestHandler>

	// register endpoint handlers
	USBHwRegisterEPIntHandler(INT_IN_EP, NULL);
    4578:	2081      	movs	r0, #129	; 0x81
    457a:	2100      	movs	r1, #0
    457c:	f000 fddc 	bl	5138 <USBHwRegisterEPIntHandler>
	USBHwRegisterEPIntHandler(BULK_IN_EP, BulkIn);
    4580:	2082      	movs	r0, #130	; 0x82
    4582:	490f      	ldr	r1, [pc, #60]	; (45c0 <usb_serial_init+0x60>)
    4584:	f000 fdd8 	bl	5138 <USBHwRegisterEPIntHandler>
	USBHwRegisterEPIntHandler(BULK_OUT_EP, BulkOut);
    4588:	2005      	movs	r0, #5
    458a:	490e      	ldr	r1, [pc, #56]	; (45c4 <usb_serial_init+0x64>)
    458c:	f000 fdd4 	bl	5138 <USBHwRegisterEPIntHandler>

	// register frame handler
	USBHwRegisterFrameHandler(USBFrameHandler);
    4590:	480d      	ldr	r0, [pc, #52]	; (45c8 <usb_serial_init+0x68>)
    4592:	f000 fe19 	bl	51c8 <USBHwRegisterFrameHandler>

	// register device event handler
	USBHwRegisterDevIntHandler(USBDevIntHandler);
    4596:	480d      	ldr	r0, [pc, #52]	; (45cc <usb_serial_init+0x6c>)
    4598:	f000 fe00 	bl	519c <USBHwRegisterDevIntHandler>

	// initialise VCOM
	VCOM_init();
    459c:	f7ff ff8e 	bl	44bc <VCOM_init>

	// enable USB interrupts
	ISER0 |= ISER0_ISE_USB;
    45a0:	4a0b      	ldr	r2, [pc, #44]	; (45d0 <usb_serial_init+0x70>)
    45a2:	4b0b      	ldr	r3, [pc, #44]	; (45d0 <usb_serial_init+0x70>)
    45a4:	681b      	ldr	r3, [r3, #0]
    45a6:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
    45aa:	6013      	str	r3, [r2, #0]

	// connect to bus
	USBHwConnect(TRUE);
    45ac:	2001      	movs	r0, #1
    45ae:	f000 fe33 	bl	5218 <USBHwConnect>
}
    45b2:	bd80      	pop	{r7, pc}
    45b4:	00005d1c 	.word	0x00005d1c
    45b8:	000042fd 	.word	0x000042fd
    45bc:	10000558 	.word	0x10000558
    45c0:	00004441 	.word	0x00004441
    45c4:	00004351 	.word	0x00004351
    45c8:	00004461 	.word	0x00004461
    45cc:	00004495 	.word	0x00004495
    45d0:	e000e100 	.word	0xe000e100

000045d4 <fifo_init>:

#include "type.h"
#include "serial_fifo.h"

void fifo_init(fifo_t *fifo, U8 *buf)
{
    45d4:	b480      	push	{r7}
    45d6:	b083      	sub	sp, #12
    45d8:	af00      	add	r7, sp, #0
    45da:	6078      	str	r0, [r7, #4]
    45dc:	6039      	str	r1, [r7, #0]
	fifo->head = 0;
    45de:	687b      	ldr	r3, [r7, #4]
    45e0:	2200      	movs	r2, #0
    45e2:	601a      	str	r2, [r3, #0]
	fifo->tail = 0;
    45e4:	687b      	ldr	r3, [r7, #4]
    45e6:	2200      	movs	r2, #0
    45e8:	605a      	str	r2, [r3, #4]
	fifo->buf = buf;
    45ea:	687b      	ldr	r3, [r7, #4]
    45ec:	683a      	ldr	r2, [r7, #0]
    45ee:	609a      	str	r2, [r3, #8]
}
    45f0:	370c      	adds	r7, #12
    45f2:	46bd      	mov	sp, r7
    45f4:	f85d 7b04 	ldr.w	r7, [sp], #4
    45f8:	4770      	bx	lr
    45fa:	bf00      	nop

000045fc <fifo_put>:


BOOL fifo_put(fifo_t *fifo, U8 c)
{
    45fc:	b480      	push	{r7}
    45fe:	b085      	sub	sp, #20
    4600:	af00      	add	r7, sp, #0
    4602:	6078      	str	r0, [r7, #4]
    4604:	460b      	mov	r3, r1
    4606:	70fb      	strb	r3, [r7, #3]
	int next;
	
	// check if FIFO has room
	next = (fifo->head + 1) % VCOM_FIFO_SIZE;
    4608:	687b      	ldr	r3, [r7, #4]
    460a:	681b      	ldr	r3, [r3, #0]
    460c:	1c5a      	adds	r2, r3, #1
    460e:	4b10      	ldr	r3, [pc, #64]	; (4650 <fifo_put+0x54>)
    4610:	4013      	ands	r3, r2
    4612:	2b00      	cmp	r3, #0
    4614:	da03      	bge.n	461e <fifo_put+0x22>
    4616:	3b01      	subs	r3, #1
    4618:	f063 037f 	orn	r3, r3, #127	; 0x7f
    461c:	3301      	adds	r3, #1
    461e:	60fb      	str	r3, [r7, #12]
	if (next == fifo->tail) {
    4620:	687b      	ldr	r3, [r7, #4]
    4622:	685a      	ldr	r2, [r3, #4]
    4624:	68fb      	ldr	r3, [r7, #12]
    4626:	429a      	cmp	r2, r3
    4628:	d101      	bne.n	462e <fifo_put+0x32>
		// full
		return FALSE;
    462a:	2300      	movs	r3, #0
    462c:	e00a      	b.n	4644 <fifo_put+0x48>
	}
	
	fifo->buf[fifo->head] = c;
    462e:	687b      	ldr	r3, [r7, #4]
    4630:	689b      	ldr	r3, [r3, #8]
    4632:	687a      	ldr	r2, [r7, #4]
    4634:	6812      	ldr	r2, [r2, #0]
    4636:	4413      	add	r3, r2
    4638:	78fa      	ldrb	r2, [r7, #3]
    463a:	701a      	strb	r2, [r3, #0]
	fifo->head = next;
    463c:	687b      	ldr	r3, [r7, #4]
    463e:	68fa      	ldr	r2, [r7, #12]
    4640:	601a      	str	r2, [r3, #0]
	
	return TRUE;
    4642:	2301      	movs	r3, #1
}
    4644:	4618      	mov	r0, r3
    4646:	3714      	adds	r7, #20
    4648:	46bd      	mov	sp, r7
    464a:	f85d 7b04 	ldr.w	r7, [sp], #4
    464e:	4770      	bx	lr
    4650:	8000007f 	.word	0x8000007f

00004654 <fifo_get>:


BOOL fifo_get(fifo_t *fifo, U8 *pc)
{
    4654:	b480      	push	{r7}
    4656:	b085      	sub	sp, #20
    4658:	af00      	add	r7, sp, #0
    465a:	6078      	str	r0, [r7, #4]
    465c:	6039      	str	r1, [r7, #0]
	int next;
	
	// check if FIFO has data
	if (fifo->head == fifo->tail) {
    465e:	687b      	ldr	r3, [r7, #4]
    4660:	681a      	ldr	r2, [r3, #0]
    4662:	687b      	ldr	r3, [r7, #4]
    4664:	685b      	ldr	r3, [r3, #4]
    4666:	429a      	cmp	r2, r3
    4668:	d101      	bne.n	466e <fifo_get+0x1a>
		return FALSE;
    466a:	2300      	movs	r3, #0
    466c:	e017      	b.n	469e <fifo_get+0x4a>
	}
	
	next = (fifo->tail + 1) % VCOM_FIFO_SIZE;
    466e:	687b      	ldr	r3, [r7, #4]
    4670:	685b      	ldr	r3, [r3, #4]
    4672:	1c5a      	adds	r2, r3, #1
    4674:	4b0d      	ldr	r3, [pc, #52]	; (46ac <fifo_get+0x58>)
    4676:	4013      	ands	r3, r2
    4678:	2b00      	cmp	r3, #0
    467a:	da03      	bge.n	4684 <fifo_get+0x30>
    467c:	3b01      	subs	r3, #1
    467e:	f063 037f 	orn	r3, r3, #127	; 0x7f
    4682:	3301      	adds	r3, #1
    4684:	60fb      	str	r3, [r7, #12]
	
	*pc = fifo->buf[fifo->tail];
    4686:	687b      	ldr	r3, [r7, #4]
    4688:	689b      	ldr	r3, [r3, #8]
    468a:	687a      	ldr	r2, [r7, #4]
    468c:	6852      	ldr	r2, [r2, #4]
    468e:	4413      	add	r3, r2
    4690:	781a      	ldrb	r2, [r3, #0]
    4692:	683b      	ldr	r3, [r7, #0]
    4694:	701a      	strb	r2, [r3, #0]
	fifo->tail = next;
    4696:	687b      	ldr	r3, [r7, #4]
    4698:	68fa      	ldr	r2, [r7, #12]
    469a:	605a      	str	r2, [r3, #4]

	return TRUE;
    469c:	2301      	movs	r3, #1
}
    469e:	4618      	mov	r0, r3
    46a0:	3714      	adds	r7, #20
    46a2:	46bd      	mov	sp, r7
    46a4:	f85d 7b04 	ldr.w	r7, [sp], #4
    46a8:	4770      	bx	lr
    46aa:	bf00      	nop
    46ac:	8000007f 	.word	0x8000007f

000046b0 <fifo_avail>:


int fifo_avail(fifo_t *fifo)
{
    46b0:	b480      	push	{r7}
    46b2:	b083      	sub	sp, #12
    46b4:	af00      	add	r7, sp, #0
    46b6:	6078      	str	r0, [r7, #4]
	return (VCOM_FIFO_SIZE + fifo->head - fifo->tail) % VCOM_FIFO_SIZE;
    46b8:	687b      	ldr	r3, [r7, #4]
    46ba:	681b      	ldr	r3, [r3, #0]
    46bc:	f103 0280 	add.w	r2, r3, #128	; 0x80
    46c0:	687b      	ldr	r3, [r7, #4]
    46c2:	685b      	ldr	r3, [r3, #4]
    46c4:	1ad2      	subs	r2, r2, r3
    46c6:	4b07      	ldr	r3, [pc, #28]	; (46e4 <fifo_avail+0x34>)
    46c8:	4013      	ands	r3, r2
    46ca:	2b00      	cmp	r3, #0
    46cc:	da03      	bge.n	46d6 <fifo_avail+0x26>
    46ce:	3b01      	subs	r3, #1
    46d0:	f063 037f 	orn	r3, r3, #127	; 0x7f
    46d4:	3301      	adds	r3, #1
}
    46d6:	4618      	mov	r0, r3
    46d8:	370c      	adds	r7, #12
    46da:	46bd      	mov	sp, r7
    46dc:	f85d 7b04 	ldr.w	r7, [sp], #4
    46e0:	4770      	bx	lr
    46e2:	bf00      	nop
    46e4:	8000007f 	.word	0x8000007f

000046e8 <fifo_free>:


int fifo_free(fifo_t *fifo)
{
    46e8:	b580      	push	{r7, lr}
    46ea:	b082      	sub	sp, #8
    46ec:	af00      	add	r7, sp, #0
    46ee:	6078      	str	r0, [r7, #4]
	return (VCOM_FIFO_SIZE - 1 - fifo_avail(fifo));
    46f0:	6878      	ldr	r0, [r7, #4]
    46f2:	f7ff ffdd 	bl	46b0 <fifo_avail>
    46f6:	4603      	mov	r3, r0
    46f8:	f1c3 037f 	rsb	r3, r3, #127	; 0x7f
}
    46fc:	4618      	mov	r0, r3
    46fe:	3708      	adds	r7, #8
    4700:	46bd      	mov	sp, r7
    4702:	bd80      	pop	{r7, pc}

00004704 <Reset_Handler>:
extern void __libc_init_array(void);
extern int main(void);

/* Reset Handler */
void Reset_Handler(void)
{
    4704:	b580      	push	{r7, lr}
    4706:	b082      	sub	sp, #8
    4708:	af00      	add	r7, sp, #0
    unsigned long *src, *dest;

	// Copy the data segment initializers from flash to SRAM
	src = &_etext;
    470a:	4b12      	ldr	r3, [pc, #72]	; (4754 <Reset_Handler+0x50>)
    470c:	607b      	str	r3, [r7, #4]
	for(dest = &_data; dest < &_edata; )
    470e:	4b12      	ldr	r3, [pc, #72]	; (4758 <Reset_Handler+0x54>)
    4710:	603b      	str	r3, [r7, #0]
    4712:	e007      	b.n	4724 <Reset_Handler+0x20>
	{
		*dest++ = *src++;
    4714:	683b      	ldr	r3, [r7, #0]
    4716:	1d1a      	adds	r2, r3, #4
    4718:	603a      	str	r2, [r7, #0]
    471a:	687a      	ldr	r2, [r7, #4]
    471c:	1d11      	adds	r1, r2, #4
    471e:	6079      	str	r1, [r7, #4]
    4720:	6812      	ldr	r2, [r2, #0]
    4722:	601a      	str	r2, [r3, #0]
{
    unsigned long *src, *dest;

	// Copy the data segment initializers from flash to SRAM
	src = &_etext;
	for(dest = &_data; dest < &_edata; )
    4724:	683b      	ldr	r3, [r7, #0]
    4726:	4a0d      	ldr	r2, [pc, #52]	; (475c <Reset_Handler+0x58>)
    4728:	4293      	cmp	r3, r2
    472a:	d3f3      	bcc.n	4714 <Reset_Handler+0x10>
	{
		*dest++ = *src++;
	}

	// Initialize the .bss segment of memory to zeros
	src = &_bss;
    472c:	4b0c      	ldr	r3, [pc, #48]	; (4760 <Reset_Handler+0x5c>)
    472e:	607b      	str	r3, [r7, #4]
	while (src < &_ebss)
    4730:	e004      	b.n	473c <Reset_Handler+0x38>
	{
		*src++ = 0;
    4732:	687b      	ldr	r3, [r7, #4]
    4734:	1d1a      	adds	r2, r3, #4
    4736:	607a      	str	r2, [r7, #4]
    4738:	2200      	movs	r2, #0
    473a:	601a      	str	r2, [r3, #0]
		*dest++ = *src++;
	}

	// Initialize the .bss segment of memory to zeros
	src = &_bss;
	while (src < &_ebss)
    473c:	687b      	ldr	r3, [r7, #4]
    473e:	4a09      	ldr	r2, [pc, #36]	; (4764 <Reset_Handler+0x60>)
    4740:	4293      	cmp	r3, r2
    4742:	d3f6      	bcc.n	4732 <Reset_Handler+0x2e>
	{
		*src++ = 0;
	}

    __libc_init_array();
    4744:	f7ff fd30 	bl	41a8 <__libc_init_array>
    
    // Set the vector table location.
    SCB_VTOR = &_interrupt_vector_table;
    4748:	4b07      	ldr	r3, [pc, #28]	; (4768 <Reset_Handler+0x64>)
    474a:	4a08      	ldr	r2, [pc, #32]	; (476c <Reset_Handler+0x68>)
    474c:	601a      	str	r2, [r3, #0]
    
	main();
    474e:	f7ff fdaf 	bl	42b0 <main>

	// In case main() fails, have something to breakpoint
	while (1) {;}
    4752:	e7fe      	b.n	4752 <Reset_Handler+0x4e>
    4754:	00005e40 	.word	0x00005e40
    4758:	10000020 	.word	0x10000020
    475c:	100004fa 	.word	0x100004fa
    4760:	100004fc 	.word	0x100004fc
    4764:	10000715 	.word	0x10000715
    4768:	e000ed08 	.word	0xe000ed08
    476c:	00004000 	.word	0x00004000

00004770 <ADC_IRQHandler>:
extern unsigned long _StackTop;

extern void Reset_Handler(void);

/* Default interrupt handler */
static void Default_Handler(void) { while(1) {;} }
    4770:	b480      	push	{r7}
    4772:	af00      	add	r7, sp, #0
    4774:	e7fe      	b.n	4774 <ADC_IRQHandler+0x4>
    4776:	bf00      	nop

00004778 <wait_us>:

/* delay a number of microseconds while on internal oscillator (4 MHz) */
/* we only have a resolution of 1000/400, so to the nearest 2.5        */
static volatile u32 wait_us_counter;
void wait_us(u32 us)
{
    4778:	b480      	push	{r7}
    477a:	b083      	sub	sp, #12
    477c:	af00      	add	r7, sp, #0
    477e:	6078      	str	r0, [r7, #4]
	/* This is binary multiply by ~0.3999, i.e, multiply by
	   0.011011011b. The loop also contains 6 instructions at -Os, so
	   why this factor works is not at all related to the comment
	   above ;-) */
	wait_us_counter =
		(us>>2) + (us>>3) + (us>>6) + (us>>7) + (us>>10) + (us>>11);
    4780:	687b      	ldr	r3, [r7, #4]
    4782:	089a      	lsrs	r2, r3, #2
    4784:	687b      	ldr	r3, [r7, #4]
    4786:	08db      	lsrs	r3, r3, #3
    4788:	441a      	add	r2, r3
    478a:	687b      	ldr	r3, [r7, #4]
    478c:	099b      	lsrs	r3, r3, #6
    478e:	441a      	add	r2, r3
    4790:	687b      	ldr	r3, [r7, #4]
    4792:	09db      	lsrs	r3, r3, #7
    4794:	441a      	add	r2, r3
    4796:	687b      	ldr	r3, [r7, #4]
    4798:	0a9b      	lsrs	r3, r3, #10
    479a:	441a      	add	r2, r3
    479c:	687b      	ldr	r3, [r7, #4]
    479e:	0adb      	lsrs	r3, r3, #11
    47a0:	4413      	add	r3, r2
{
	/* This is binary multiply by ~0.3999, i.e, multiply by
	   0.011011011b. The loop also contains 6 instructions at -Os, so
	   why this factor works is not at all related to the comment
	   above ;-) */
	wait_us_counter =
    47a2:	4a07      	ldr	r2, [pc, #28]	; (47c0 <wait_us+0x48>)
    47a4:	6013      	str	r3, [r2, #0]
		(us>>2) + (us>>3) + (us>>6) + (us>>7) + (us>>10) + (us>>11);
	while(--wait_us_counter);
    47a6:	bf00      	nop
    47a8:	4b05      	ldr	r3, [pc, #20]	; (47c0 <wait_us+0x48>)
    47aa:	681b      	ldr	r3, [r3, #0]
    47ac:	3b01      	subs	r3, #1
    47ae:	4a04      	ldr	r2, [pc, #16]	; (47c0 <wait_us+0x48>)
    47b0:	6013      	str	r3, [r2, #0]
    47b2:	2b00      	cmp	r3, #0
    47b4:	d1f8      	bne.n	47a8 <wait_us+0x30>
}
    47b6:	370c      	adds	r7, #12
    47b8:	46bd      	mov	sp, r7
    47ba:	f85d 7b04 	ldr.w	r7, [sp], #4
    47be:	4770      	bx	lr
    47c0:	10000680 	.word	0x10000680

000047c4 <gpio_init>:
/*
 * This should be called very early by every firmware in order to ensure safe
 * operating conditions for the CC2400.
 */
void gpio_init()
{
    47c4:	b580      	push	{r7, lr}
    47c6:	af00      	add	r7, sp, #0
	/* 
	 * Set all pins for GPIO.  This shouldn't be necessary after a reset, but
	 * we might get called at other times.
	 */
	all_pins_off();
    47c8:	f000 f836 	bl	4838 <all_pins_off>
	FIO2DIR = PIN_SSEL0;
	FIO3DIR = 0;
	FIO4DIR = (PIN_RXLED | PIN_TXLED);
#endif
#ifdef UBERTOOTH_ONE
	FIO0DIR = 0;
    47cc:	4b10      	ldr	r3, [pc, #64]	; (4810 <gpio_init+0x4c>)
    47ce:	2200      	movs	r2, #0
    47d0:	601a      	str	r2, [r3, #0]
	FIO1DIR = (PIN_USRLED | PIN_RXLED | PIN_TXLED | PIN_CC3V3 |
    47d2:	4b10      	ldr	r3, [pc, #64]	; (4814 <gpio_init+0x50>)
    47d4:	f24c 7212 	movw	r2, #50962	; 0xc712
    47d8:	601a      	str	r2, [r3, #0]
			PIN_RX | PIN_CC1V8 | PIN_BTGR);
	FIO2DIR = (PIN_CSN | PIN_SCLK | PIN_MOSI | PIN_PAEN | PIN_HGM);
    47da:	4b0f      	ldr	r3, [pc, #60]	; (4818 <gpio_init+0x54>)
    47dc:	f240 12b1 	movw	r2, #433	; 0x1b1
    47e0:	601a      	str	r2, [r3, #0]
	FIO3DIR = 0;
    47e2:	4b0e      	ldr	r3, [pc, #56]	; (481c <gpio_init+0x58>)
    47e4:	2200      	movs	r2, #0
    47e6:	601a      	str	r2, [r3, #0]
	FIO4DIR = (PIN_TX | PIN_SSEL1);
    47e8:	4b0d      	ldr	r3, [pc, #52]	; (4820 <gpio_init+0x5c>)
    47ea:	f04f 5240 	mov.w	r2, #805306368	; 0x30000000
    47ee:	601a      	str	r2, [r3, #0]
	FIO3DIR = 0;
	FIO4DIR = 0;
#endif

	/* set all outputs low */
	FIO0PIN = 0;
    47f0:	4b0c      	ldr	r3, [pc, #48]	; (4824 <gpio_init+0x60>)
    47f2:	2200      	movs	r2, #0
    47f4:	601a      	str	r2, [r3, #0]
	FIO1PIN = 0;
    47f6:	4b0c      	ldr	r3, [pc, #48]	; (4828 <gpio_init+0x64>)
    47f8:	2200      	movs	r2, #0
    47fa:	601a      	str	r2, [r3, #0]
	FIO2PIN = 0;
    47fc:	4b0b      	ldr	r3, [pc, #44]	; (482c <gpio_init+0x68>)
    47fe:	2200      	movs	r2, #0
    4800:	601a      	str	r2, [r3, #0]
	FIO3PIN = 0;
    4802:	4b0b      	ldr	r3, [pc, #44]	; (4830 <gpio_init+0x6c>)
    4804:	2200      	movs	r2, #0
    4806:	601a      	str	r2, [r3, #0]
	FIO4PIN = 0;
    4808:	4b0a      	ldr	r3, [pc, #40]	; (4834 <gpio_init+0x70>)
    480a:	2200      	movs	r2, #0
    480c:	601a      	str	r2, [r3, #0]

#ifdef TC13BADGE
	/* R8C_CTL is active low */
	R8C_CTL_SET;
#endif
}
    480e:	bd80      	pop	{r7, pc}
    4810:	2009c000 	.word	0x2009c000
    4814:	2009c020 	.word	0x2009c020
    4818:	2009c040 	.word	0x2009c040
    481c:	2009c060 	.word	0x2009c060
    4820:	2009c080 	.word	0x2009c080
    4824:	2009c014 	.word	0x2009c014
    4828:	2009c034 	.word	0x2009c034
    482c:	2009c054 	.word	0x2009c054
    4830:	2009c074 	.word	0x2009c074
    4834:	2009c094 	.word	0x2009c094

00004838 <all_pins_off>:

void all_pins_off(void)
{
    4838:	b480      	push	{r7}
    483a:	af00      	add	r7, sp, #0
	/* configure all pins for GPIO */
	PINSEL0 = 0;
    483c:	4b27      	ldr	r3, [pc, #156]	; (48dc <all_pins_off+0xa4>)
    483e:	2200      	movs	r2, #0
    4840:	601a      	str	r2, [r3, #0]
	PINSEL1 = 0;
    4842:	4b27      	ldr	r3, [pc, #156]	; (48e0 <all_pins_off+0xa8>)
    4844:	2200      	movs	r2, #0
    4846:	601a      	str	r2, [r3, #0]
	PINSEL2 = 0;
    4848:	4b26      	ldr	r3, [pc, #152]	; (48e4 <all_pins_off+0xac>)
    484a:	2200      	movs	r2, #0
    484c:	601a      	str	r2, [r3, #0]
	PINSEL3 = 0;
    484e:	4b26      	ldr	r3, [pc, #152]	; (48e8 <all_pins_off+0xb0>)
    4850:	2200      	movs	r2, #0
    4852:	601a      	str	r2, [r3, #0]
	PINSEL4 = 0;
    4854:	4b25      	ldr	r3, [pc, #148]	; (48ec <all_pins_off+0xb4>)
    4856:	2200      	movs	r2, #0
    4858:	601a      	str	r2, [r3, #0]
	PINSEL7 = 0;
    485a:	4b25      	ldr	r3, [pc, #148]	; (48f0 <all_pins_off+0xb8>)
    485c:	2200      	movs	r2, #0
    485e:	601a      	str	r2, [r3, #0]
	PINSEL9 = 0;
    4860:	4b24      	ldr	r3, [pc, #144]	; (48f4 <all_pins_off+0xbc>)
    4862:	2200      	movs	r2, #0
    4864:	601a      	str	r2, [r3, #0]
	PINSEL10 = 0;
    4866:	4b24      	ldr	r3, [pc, #144]	; (48f8 <all_pins_off+0xc0>)
    4868:	2200      	movs	r2, #0
    486a:	601a      	str	r2, [r3, #0]

	/* configure all pins as inputs */
	FIO0DIR = 0;
    486c:	4b23      	ldr	r3, [pc, #140]	; (48fc <all_pins_off+0xc4>)
    486e:	2200      	movs	r2, #0
    4870:	601a      	str	r2, [r3, #0]
	FIO1DIR = 0;
    4872:	4b23      	ldr	r3, [pc, #140]	; (4900 <all_pins_off+0xc8>)
    4874:	2200      	movs	r2, #0
    4876:	601a      	str	r2, [r3, #0]
	FIO2DIR = 0;
    4878:	4b22      	ldr	r3, [pc, #136]	; (4904 <all_pins_off+0xcc>)
    487a:	2200      	movs	r2, #0
    487c:	601a      	str	r2, [r3, #0]
	FIO3DIR = 0;
    487e:	4b22      	ldr	r3, [pc, #136]	; (4908 <all_pins_off+0xd0>)
    4880:	2200      	movs	r2, #0
    4882:	601a      	str	r2, [r3, #0]
	FIO4DIR = 0;
    4884:	4b21      	ldr	r3, [pc, #132]	; (490c <all_pins_off+0xd4>)
    4886:	2200      	movs	r2, #0
    4888:	601a      	str	r2, [r3, #0]

	/* pull-up on every pin */
	PINMODE0 = 0;
    488a:	4b21      	ldr	r3, [pc, #132]	; (4910 <all_pins_off+0xd8>)
    488c:	2200      	movs	r2, #0
    488e:	601a      	str	r2, [r3, #0]
	PINMODE1 = 0;
    4890:	4b20      	ldr	r3, [pc, #128]	; (4914 <all_pins_off+0xdc>)
    4892:	2200      	movs	r2, #0
    4894:	601a      	str	r2, [r3, #0]
	PINMODE2 = 0;
    4896:	4b20      	ldr	r3, [pc, #128]	; (4918 <all_pins_off+0xe0>)
    4898:	2200      	movs	r2, #0
    489a:	601a      	str	r2, [r3, #0]
	PINMODE3 = 0;
    489c:	4b1f      	ldr	r3, [pc, #124]	; (491c <all_pins_off+0xe4>)
    489e:	2200      	movs	r2, #0
    48a0:	601a      	str	r2, [r3, #0]
	PINMODE4 = 0;
    48a2:	4b1f      	ldr	r3, [pc, #124]	; (4920 <all_pins_off+0xe8>)
    48a4:	2200      	movs	r2, #0
    48a6:	601a      	str	r2, [r3, #0]
	PINMODE7 = 0;
    48a8:	4b1e      	ldr	r3, [pc, #120]	; (4924 <all_pins_off+0xec>)
    48aa:	2200      	movs	r2, #0
    48ac:	601a      	str	r2, [r3, #0]
	PINMODE9 = 0;
    48ae:	4b1e      	ldr	r3, [pc, #120]	; (4928 <all_pins_off+0xf0>)
    48b0:	2200      	movs	r2, #0
    48b2:	601a      	str	r2, [r3, #0]

	/* set all outputs low */
	FIO0PIN = 0;
    48b4:	4b1d      	ldr	r3, [pc, #116]	; (492c <all_pins_off+0xf4>)
    48b6:	2200      	movs	r2, #0
    48b8:	601a      	str	r2, [r3, #0]
	FIO1PIN = 0;
    48ba:	4b1d      	ldr	r3, [pc, #116]	; (4930 <all_pins_off+0xf8>)
    48bc:	2200      	movs	r2, #0
    48be:	601a      	str	r2, [r3, #0]
	FIO2PIN = 0;
    48c0:	4b1c      	ldr	r3, [pc, #112]	; (4934 <all_pins_off+0xfc>)
    48c2:	2200      	movs	r2, #0
    48c4:	601a      	str	r2, [r3, #0]
	FIO3PIN = 0;
    48c6:	4b1c      	ldr	r3, [pc, #112]	; (4938 <all_pins_off+0x100>)
    48c8:	2200      	movs	r2, #0
    48ca:	601a      	str	r2, [r3, #0]
	FIO4PIN = 0;
    48cc:	4b1b      	ldr	r3, [pc, #108]	; (493c <all_pins_off+0x104>)
    48ce:	2200      	movs	r2, #0
    48d0:	601a      	str	r2, [r3, #0]
}
    48d2:	46bd      	mov	sp, r7
    48d4:	f85d 7b04 	ldr.w	r7, [sp], #4
    48d8:	4770      	bx	lr
    48da:	bf00      	nop
    48dc:	4002c000 	.word	0x4002c000
    48e0:	4002c004 	.word	0x4002c004
    48e4:	4002c008 	.word	0x4002c008
    48e8:	4002c00c 	.word	0x4002c00c
    48ec:	4002c010 	.word	0x4002c010
    48f0:	4002c01c 	.word	0x4002c01c
    48f4:	4002c024 	.word	0x4002c024
    48f8:	4002c028 	.word	0x4002c028
    48fc:	2009c000 	.word	0x2009c000
    4900:	2009c020 	.word	0x2009c020
    4904:	2009c040 	.word	0x2009c040
    4908:	2009c060 	.word	0x2009c060
    490c:	2009c080 	.word	0x2009c080
    4910:	4002c040 	.word	0x4002c040
    4914:	4002c044 	.word	0x4002c044
    4918:	4002c048 	.word	0x4002c048
    491c:	4002c04c 	.word	0x4002c04c
    4920:	4002c050 	.word	0x4002c050
    4924:	4002c05c 	.word	0x4002c05c
    4928:	4002c064 	.word	0x4002c064
    492c:	2009c014 	.word	0x2009c014
    4930:	2009c034 	.word	0x2009c034
    4934:	2009c054 	.word	0x2009c054
    4938:	2009c074 	.word	0x2009c074
    493c:	2009c094 	.word	0x2009c094

00004940 <ubertooth_init>:
/*
 * Every application that uses the main oscillator (including any that use both
 * USB and the CC2400) should start with this.
 */
void ubertooth_init()
{
    4940:	b580      	push	{r7, lr}
    4942:	af00      	add	r7, sp, #0
	gpio_init();
    4944:	f7ff ff3e 	bl	47c4 <gpio_init>
	cc2400_init();
    4948:	f000 f828 	bl	499c <cc2400_init>
	clock_start();
    494c:	f000 f8e6 	bl	4b1c <clock_start>
}
    4950:	bd80      	pop	{r7, pc}
    4952:	bf00      	nop

00004954 <atest_init>:
	DIO_SSP_CR0 = (0x7 /* 8 bit transfer */ | SSPCR0_CPOL | SSPCR0_CPHA);
	DIO_SSP_CR1 = (SSPCR1_MS | SSPCR1_SOD);
}

void atest_init()
{
    4954:	b480      	push	{r7}
    4956:	af00      	add	r7, sp, #0
	 * ADC can optionally be configured for ATEST1 and ATEST2, but for now we
	 * set them as floating inputs.
	 */

	/* P0.25 is ATEST1, P0.26 is ATEST2 */
	PINSEL1 &= ~((0x3 << 20) | (0x3 << 18)); // set as GPIO
    4958:	4a0d      	ldr	r2, [pc, #52]	; (4990 <atest_init+0x3c>)
    495a:	4b0d      	ldr	r3, [pc, #52]	; (4990 <atest_init+0x3c>)
    495c:	681b      	ldr	r3, [r3, #0]
    495e:	f423 1370 	bic.w	r3, r3, #3932160	; 0x3c0000
    4962:	6013      	str	r3, [r2, #0]
	FIO0DIR &= ~(0x3 << 25); // set as input
    4964:	4a0b      	ldr	r2, [pc, #44]	; (4994 <atest_init+0x40>)
    4966:	4b0b      	ldr	r3, [pc, #44]	; (4994 <atest_init+0x40>)
    4968:	681b      	ldr	r3, [r3, #0]
    496a:	f023 63c0 	bic.w	r3, r3, #100663296	; 0x6000000
    496e:	6013      	str	r3, [r2, #0]
	PINMODE1 |= (0x5 << 19); // no pull-up/pull-down
    4970:	4a09      	ldr	r2, [pc, #36]	; (4998 <atest_init+0x44>)
    4972:	4b09      	ldr	r3, [pc, #36]	; (4998 <atest_init+0x44>)
    4974:	681b      	ldr	r3, [r3, #0]
    4976:	f443 1320 	orr.w	r3, r3, #2621440	; 0x280000
    497a:	6013      	str	r3, [r2, #0]
	PINMODE1 &= ~(0x5 << 18); // no pull-up/pull-down
    497c:	4a06      	ldr	r2, [pc, #24]	; (4998 <atest_init+0x44>)
    497e:	4b06      	ldr	r3, [pc, #24]	; (4998 <atest_init+0x44>)
    4980:	681b      	ldr	r3, [r3, #0]
    4982:	f423 13a0 	bic.w	r3, r3, #1310720	; 0x140000
    4986:	6013      	str	r3, [r2, #0]
}
    4988:	46bd      	mov	sp, r7
    498a:	f85d 7b04 	ldr.w	r7, [sp], #4
    498e:	4770      	bx	lr
    4990:	4002c004 	.word	0x4002c004
    4994:	2009c000 	.word	0x2009c000
    4998:	4002c044 	.word	0x4002c044

0000499c <cc2400_init>:

void cc2400_init()
{
    499c:	b580      	push	{r7, lr}
    499e:	af00      	add	r7, sp, #0
	FIO1PIN = 0; /* assuming we have already asserted R8C_CTL low */
	FIO2PIN = 0;
	FIO3PIN = 0;
	FIO4PIN = 0;
#else
	atest_init();
    49a0:	f7ff ffd8 	bl	4954 <atest_init>
#endif

	/* activate 1V8 supply for CC2400 */
	CC1V8_SET;
    49a4:	4b09      	ldr	r3, [pc, #36]	; (49cc <cc2400_init+0x30>)
    49a6:	f44f 7200 	mov.w	r2, #512	; 0x200
    49aa:	601a      	str	r2, [r3, #0]
	wait_us(50);
    49ac:	2032      	movs	r0, #50	; 0x32
    49ae:	f7ff fee3 	bl	4778 <wait_us>

	/* CSN (slave select) is active low */
	CSN_SET;
    49b2:	4b07      	ldr	r3, [pc, #28]	; (49d0 <cc2400_init+0x34>)
    49b4:	2220      	movs	r2, #32
    49b6:	601a      	str	r2, [r3, #0]

	/* activate 3V3 supply for CC2400 IO */
	CC3V3_SET;
    49b8:	4b04      	ldr	r3, [pc, #16]	; (49cc <cc2400_init+0x30>)
    49ba:	f44f 4280 	mov.w	r2, #16384	; 0x4000
    49be:	601a      	str	r2, [r3, #0]

	/* initialise various cc2400 settings - see datasheet pg63 */
	cc2400_set(MANAND,  0x7fff);
    49c0:	200d      	movs	r0, #13
    49c2:	f647 71ff 	movw	r1, #32767	; 0x7fff
    49c6:	f000 f85f 	bl	4a88 <cc2400_set>
}
    49ca:	bd80      	pop	{r7, pc}
    49cc:	2009c038 	.word	0x2009c038
    49d0:	2009c058 	.word	0x2009c058

000049d4 <cc2400_spi>:
 * 2. We're saving the second SPI peripheral for an expansion port.
 * 3. The CC2400 needs CSN held low for the entire transaction which the
 *    LPC17xx SPI peripheral won't do without some workaround anyway.
 */
u32 cc2400_spi(u8 len, u32 data)
{
    49d4:	b480      	push	{r7}
    49d6:	b085      	sub	sp, #20
    49d8:	af00      	add	r7, sp, #0
    49da:	4603      	mov	r3, r0
    49dc:	6039      	str	r1, [r7, #0]
    49de:	71fb      	strb	r3, [r7, #7]
	u32 msb = 1 << (len - 1);
    49e0:	79fb      	ldrb	r3, [r7, #7]
    49e2:	3b01      	subs	r3, #1
    49e4:	2201      	movs	r2, #1
    49e6:	fa02 f303 	lsl.w	r3, r2, r3
    49ea:	60fb      	str	r3, [r7, #12]

	/* start transaction by dropping CSN */
	CSN_CLR;
    49ec:	4b18      	ldr	r3, [pc, #96]	; (4a50 <cc2400_spi+0x7c>)
    49ee:	2220      	movs	r2, #32
    49f0:	601a      	str	r2, [r3, #0]

	while (len--) {
    49f2:	e01e      	b.n	4a32 <cc2400_spi+0x5e>
		if (data & msb)
    49f4:	683a      	ldr	r2, [r7, #0]
    49f6:	68fb      	ldr	r3, [r7, #12]
    49f8:	4013      	ands	r3, r2
    49fa:	2b00      	cmp	r3, #0
    49fc:	d003      	beq.n	4a06 <cc2400_spi+0x32>
			MOSI_SET;
    49fe:	4b15      	ldr	r3, [pc, #84]	; (4a54 <cc2400_spi+0x80>)
    4a00:	2201      	movs	r2, #1
    4a02:	601a      	str	r2, [r3, #0]
    4a04:	e002      	b.n	4a0c <cc2400_spi+0x38>
		else
			MOSI_CLR;
    4a06:	4b12      	ldr	r3, [pc, #72]	; (4a50 <cc2400_spi+0x7c>)
    4a08:	2201      	movs	r2, #1
    4a0a:	601a      	str	r2, [r3, #0]
		data <<= 1;
    4a0c:	683b      	ldr	r3, [r7, #0]
    4a0e:	005b      	lsls	r3, r3, #1
    4a10:	603b      	str	r3, [r7, #0]

		SCLK_SET;
    4a12:	4b10      	ldr	r3, [pc, #64]	; (4a54 <cc2400_spi+0x80>)
    4a14:	2210      	movs	r2, #16
    4a16:	601a      	str	r2, [r3, #0]
		if (MISO)
    4a18:	4b0f      	ldr	r3, [pc, #60]	; (4a58 <cc2400_spi+0x84>)
    4a1a:	681b      	ldr	r3, [r3, #0]
    4a1c:	f003 0302 	and.w	r3, r3, #2
    4a20:	2b00      	cmp	r3, #0
    4a22:	d003      	beq.n	4a2c <cc2400_spi+0x58>
			data |= 1;
    4a24:	683b      	ldr	r3, [r7, #0]
    4a26:	f043 0301 	orr.w	r3, r3, #1
    4a2a:	603b      	str	r3, [r7, #0]

		SCLK_CLR;
    4a2c:	4b08      	ldr	r3, [pc, #32]	; (4a50 <cc2400_spi+0x7c>)
    4a2e:	2210      	movs	r2, #16
    4a30:	601a      	str	r2, [r3, #0]
	u32 msb = 1 << (len - 1);

	/* start transaction by dropping CSN */
	CSN_CLR;

	while (len--) {
    4a32:	79fb      	ldrb	r3, [r7, #7]
    4a34:	1e5a      	subs	r2, r3, #1
    4a36:	71fa      	strb	r2, [r7, #7]
    4a38:	2b00      	cmp	r3, #0
    4a3a:	d1db      	bne.n	49f4 <cc2400_spi+0x20>

		SCLK_CLR;
	}

	/* end transaction by raising CSN */
	CSN_SET;
    4a3c:	4b05      	ldr	r3, [pc, #20]	; (4a54 <cc2400_spi+0x80>)
    4a3e:	2220      	movs	r2, #32
    4a40:	601a      	str	r2, [r3, #0]

	return data;
    4a42:	683b      	ldr	r3, [r7, #0]
}
    4a44:	4618      	mov	r0, r3
    4a46:	3714      	adds	r7, #20
    4a48:	46bd      	mov	sp, r7
    4a4a:	f85d 7b04 	ldr.w	r7, [sp], #4
    4a4e:	4770      	bx	lr
    4a50:	2009c05c 	.word	0x2009c05c
    4a54:	2009c058 	.word	0x2009c058
    4a58:	2009c054 	.word	0x2009c054

00004a5c <cc2400_get>:

/* read 16 bit value from a register */
u16 cc2400_get(u8 reg)
{
    4a5c:	b580      	push	{r7, lr}
    4a5e:	b084      	sub	sp, #16
    4a60:	af00      	add	r7, sp, #0
    4a62:	4603      	mov	r3, r0
    4a64:	71fb      	strb	r3, [r7, #7]
	u32 in;

	u32 out = (reg | 0x80) << 16;
    4a66:	79fb      	ldrb	r3, [r7, #7]
    4a68:	f063 037f 	orn	r3, r3, #127	; 0x7f
    4a6c:	b2db      	uxtb	r3, r3
    4a6e:	041b      	lsls	r3, r3, #16
    4a70:	60fb      	str	r3, [r7, #12]
	in = cc2400_spi(24, out);
    4a72:	2018      	movs	r0, #24
    4a74:	68f9      	ldr	r1, [r7, #12]
    4a76:	f7ff ffad 	bl	49d4 <cc2400_spi>
    4a7a:	60b8      	str	r0, [r7, #8]
	return in & 0xFFFF;
    4a7c:	68bb      	ldr	r3, [r7, #8]
    4a7e:	b29b      	uxth	r3, r3
}
    4a80:	4618      	mov	r0, r3
    4a82:	3710      	adds	r7, #16
    4a84:	46bd      	mov	sp, r7
    4a86:	bd80      	pop	{r7, pc}

00004a88 <cc2400_set>:

/* write 16 bit value to a register */
void cc2400_set(u8 reg, u16 val)
{
    4a88:	b580      	push	{r7, lr}
    4a8a:	b084      	sub	sp, #16
    4a8c:	af00      	add	r7, sp, #0
    4a8e:	4603      	mov	r3, r0
    4a90:	460a      	mov	r2, r1
    4a92:	71fb      	strb	r3, [r7, #7]
    4a94:	4613      	mov	r3, r2
    4a96:	80bb      	strh	r3, [r7, #4]
	u32 out = (reg << 16) | val;
    4a98:	79fb      	ldrb	r3, [r7, #7]
    4a9a:	041a      	lsls	r2, r3, #16
    4a9c:	88bb      	ldrh	r3, [r7, #4]
    4a9e:	4313      	orrs	r3, r2
    4aa0:	60fb      	str	r3, [r7, #12]
	cc2400_spi(24, out);
    4aa2:	2018      	movs	r0, #24
    4aa4:	68f9      	ldr	r1, [r7, #12]
    4aa6:	f7ff ff95 	bl	49d4 <cc2400_spi>
}
    4aaa:	3710      	adds	r7, #16
    4aac:	46bd      	mov	sp, r7
    4aae:	bd80      	pop	{r7, pc}

00004ab0 <cc2400_status>:
	CSN_SET;
}

/* get the status */
u8 cc2400_status()
{
    4ab0:	b580      	push	{r7, lr}
    4ab2:	af00      	add	r7, sp, #0
	return cc2400_spi(8, 0);
    4ab4:	2008      	movs	r0, #8
    4ab6:	2100      	movs	r1, #0
    4ab8:	f7ff ff8c 	bl	49d4 <cc2400_spi>
    4abc:	4603      	mov	r3, r0
    4abe:	b2db      	uxtb	r3, r3
}
    4ac0:	4618      	mov	r0, r3
    4ac2:	bd80      	pop	{r7, pc}

00004ac4 <cc2400_strobe>:

/* strobe register, return status */
u8 cc2400_strobe(u8 reg)
{
    4ac4:	b580      	push	{r7, lr}
    4ac6:	b082      	sub	sp, #8
    4ac8:	af00      	add	r7, sp, #0
    4aca:	4603      	mov	r3, r0
    4acc:	71fb      	strb	r3, [r7, #7]
	return cc2400_spi(8, reg);
    4ace:	79fb      	ldrb	r3, [r7, #7]
    4ad0:	2008      	movs	r0, #8
    4ad2:	4619      	mov	r1, r3
    4ad4:	f7ff ff7e 	bl	49d4 <cc2400_spi>
    4ad8:	4603      	mov	r3, r0
    4ada:	b2db      	uxtb	r3, r3
}
    4adc:	4618      	mov	r0, r3
    4ade:	3708      	adds	r7, #8
    4ae0:	46bd      	mov	sp, r7
    4ae2:	bd80      	pop	{r7, pc}

00004ae4 <cc2400_reset>:
/*
 * Warning: This should only be called when running on the internal oscillator.
 * Otherwise use clock_start().
 */
void cc2400_reset()
{
    4ae4:	b580      	push	{r7, lr}
    4ae6:	af00      	add	r7, sp, #0
	cc2400_set(MAIN, 0x0000);
    4ae8:	2000      	movs	r0, #0
    4aea:	2100      	movs	r1, #0
    4aec:	f7ff ffcc 	bl	4a88 <cc2400_set>
	while (cc2400_get(MAIN) != 0x0000);
    4af0:	bf00      	nop
    4af2:	2000      	movs	r0, #0
    4af4:	f7ff ffb2 	bl	4a5c <cc2400_get>
    4af8:	4603      	mov	r3, r0
    4afa:	2b00      	cmp	r3, #0
    4afc:	d1f9      	bne.n	4af2 <cc2400_reset+0xe>
	cc2400_set(MAIN, 0x8000);
    4afe:	2000      	movs	r0, #0
    4b00:	f44f 4100 	mov.w	r1, #32768	; 0x8000
    4b04:	f7ff ffc0 	bl	4a88 <cc2400_set>
	while (cc2400_get(MAIN) != 0x8000);
    4b08:	bf00      	nop
    4b0a:	2000      	movs	r0, #0
    4b0c:	f7ff ffa6 	bl	4a5c <cc2400_get>
    4b10:	4603      	mov	r3, r0
    4b12:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
    4b16:	d1f8      	bne.n	4b0a <cc2400_reset+0x26>
}
    4b18:	bd80      	pop	{r7, pc}
    4b1a:	bf00      	nop

00004b1c <clock_start>:

/* activate the CC2400's 16 MHz oscillator and sync LPC175x to it */
void clock_start()
{
    4b1c:	b580      	push	{r7, lr}
    4b1e:	af00      	add	r7, sp, #0
	/* configure flash accelerator for higher clock rate */
	FLASHCFG = (0x03A | (FLASHTIM << 12));
    4b20:	4b5e      	ldr	r3, [pc, #376]	; (4c9c <clock_start+0x180>)
    4b22:	f244 023a 	movw	r2, #16442	; 0x403a
    4b26:	601a      	str	r2, [r3, #0]

	/* switch to the internal oscillator if necessary */
	CLKSRCSEL = 0;
    4b28:	4b5d      	ldr	r3, [pc, #372]	; (4ca0 <clock_start+0x184>)
    4b2a:	2200      	movs	r2, #0
    4b2c:	601a      	str	r2, [r3, #0]

	/* disconnect PLL0 */
	PLL0CON &= ~PLL0CON_PLLC0;
    4b2e:	4a5d      	ldr	r2, [pc, #372]	; (4ca4 <clock_start+0x188>)
    4b30:	4b5c      	ldr	r3, [pc, #368]	; (4ca4 <clock_start+0x188>)
    4b32:	681b      	ldr	r3, [r3, #0]
    4b34:	f023 0302 	bic.w	r3, r3, #2
    4b38:	6013      	str	r3, [r2, #0]
	PLL0FEED_SEQUENCE;
    4b3a:	4b5b      	ldr	r3, [pc, #364]	; (4ca8 <clock_start+0x18c>)
    4b3c:	22aa      	movs	r2, #170	; 0xaa
    4b3e:	601a      	str	r2, [r3, #0]
    4b40:	4b59      	ldr	r3, [pc, #356]	; (4ca8 <clock_start+0x18c>)
    4b42:	2255      	movs	r2, #85	; 0x55
    4b44:	601a      	str	r2, [r3, #0]
	while (PLL0STAT & PLL0STAT_PLLC0_STAT);
    4b46:	bf00      	nop
    4b48:	4b58      	ldr	r3, [pc, #352]	; (4cac <clock_start+0x190>)
    4b4a:	681b      	ldr	r3, [r3, #0]
    4b4c:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
    4b50:	2b00      	cmp	r3, #0
    4b52:	d1f9      	bne.n	4b48 <clock_start+0x2c>

	/* turn off PLL0 */
	PLL0CON &= ~PLL0CON_PLLE0;
    4b54:	4a53      	ldr	r2, [pc, #332]	; (4ca4 <clock_start+0x188>)
    4b56:	4b53      	ldr	r3, [pc, #332]	; (4ca4 <clock_start+0x188>)
    4b58:	681b      	ldr	r3, [r3, #0]
    4b5a:	f023 0301 	bic.w	r3, r3, #1
    4b5e:	6013      	str	r3, [r2, #0]
	PLL0FEED_SEQUENCE;
    4b60:	4b51      	ldr	r3, [pc, #324]	; (4ca8 <clock_start+0x18c>)
    4b62:	22aa      	movs	r2, #170	; 0xaa
    4b64:	601a      	str	r2, [r3, #0]
    4b66:	4b50      	ldr	r3, [pc, #320]	; (4ca8 <clock_start+0x18c>)
    4b68:	2255      	movs	r2, #85	; 0x55
    4b6a:	601a      	str	r2, [r3, #0]
	while (PLL0STAT & PLL0STAT_PLLE0_STAT);
    4b6c:	bf00      	nop
    4b6e:	4b4f      	ldr	r3, [pc, #316]	; (4cac <clock_start+0x190>)
    4b70:	681b      	ldr	r3, [r3, #0]
    4b72:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
    4b76:	2b00      	cmp	r3, #0
    4b78:	d1f9      	bne.n	4b6e <clock_start+0x52>

	/* temporarily set CPU clock divider to 1 */
	CCLKCFG = 0;
    4b7a:	4b4d      	ldr	r3, [pc, #308]	; (4cb0 <clock_start+0x194>)
    4b7c:	2200      	movs	r2, #0
    4b7e:	601a      	str	r2, [r3, #0]

	/* configure CC2400 oscillator, output carrier sense on GIO6 */
	cc2400_reset();
    4b80:	f7ff ffb0 	bl	4ae4 <cc2400_reset>
	cc2400_set(IOCFG, (GIO_CARRIER_SENSE_N << 9) | (GIO_CLK_16M << 3));
    4b84:	2008      	movs	r0, #8
    4b86:	f241 5170 	movw	r1, #5488	; 0x1570
    4b8a:	f7ff ff7d 	bl	4a88 <cc2400_set>
	cc2400_strobe(SXOSCON);
    4b8e:	2060      	movs	r0, #96	; 0x60
    4b90:	f7ff ff98 	bl	4ac4 <cc2400_strobe>
	while (!(cc2400_status() & XOSC16M_STABLE));
    4b94:	bf00      	nop
    4b96:	f7ff ff8b 	bl	4ab0 <cc2400_status>
    4b9a:	4603      	mov	r3, r0
    4b9c:	f003 0340 	and.w	r3, r3, #64	; 0x40
    4ba0:	2b00      	cmp	r3, #0
    4ba2:	d0f8      	beq.n	4b96 <clock_start+0x7a>

	/* activate main oscillator */
	SCS = SCS_OSCEN;
    4ba4:	4b43      	ldr	r3, [pc, #268]	; (4cb4 <clock_start+0x198>)
    4ba6:	2220      	movs	r2, #32
    4ba8:	601a      	str	r2, [r3, #0]
	while (!(SCS & SCS_OSCSTAT));
    4baa:	bf00      	nop
    4bac:	4b41      	ldr	r3, [pc, #260]	; (4cb4 <clock_start+0x198>)
    4bae:	681b      	ldr	r3, [r3, #0]
    4bb0:	f003 0340 	and.w	r3, r3, #64	; 0x40
    4bb4:	2b00      	cmp	r3, #0
    4bb6:	d0f9      	beq.n	4bac <clock_start+0x90>
	 * connecting PLL0
 	 */
#ifdef TC13BADGE
	PCLKSEL0  = (1 << 2); /* TIMER0 at cclk (30 MHz) */
#else
	PCLKSEL0  = (2 << 2); /* TIMER0 at cclk/2 (50 MHz) */
    4bb8:	4b3f      	ldr	r3, [pc, #252]	; (4cb8 <clock_start+0x19c>)
    4bba:	2208      	movs	r2, #8
    4bbc:	601a      	str	r2, [r3, #0]
#endif
	PCLKSEL1  = 0;
    4bbe:	4b3f      	ldr	r3, [pc, #252]	; (4cbc <clock_start+0x1a0>)
    4bc0:	2200      	movs	r2, #0
    4bc2:	601a      	str	r2, [r3, #0]

	/* switch to main oscillator */
	CLKSRCSEL = 1;
    4bc4:	4b36      	ldr	r3, [pc, #216]	; (4ca0 <clock_start+0x184>)
    4bc6:	2201      	movs	r2, #1
    4bc8:	601a      	str	r2, [r3, #0]

	/* configure PLL0 */
	PLL0CFG = (MSEL0 << 0) | (NSEL0 << 16);
    4bca:	4b3d      	ldr	r3, [pc, #244]	; (4cc0 <clock_start+0x1a4>)
    4bcc:	4a3d      	ldr	r2, [pc, #244]	; (4cc4 <clock_start+0x1a8>)
    4bce:	601a      	str	r2, [r3, #0]
	PLL0FEED_SEQUENCE;
    4bd0:	4b35      	ldr	r3, [pc, #212]	; (4ca8 <clock_start+0x18c>)
    4bd2:	22aa      	movs	r2, #170	; 0xaa
    4bd4:	601a      	str	r2, [r3, #0]
    4bd6:	4b34      	ldr	r3, [pc, #208]	; (4ca8 <clock_start+0x18c>)
    4bd8:	2255      	movs	r2, #85	; 0x55
    4bda:	601a      	str	r2, [r3, #0]

	/* turn on PLL0 */
	PLL0CON |= PLL0CON_PLLE0;
    4bdc:	4a31      	ldr	r2, [pc, #196]	; (4ca4 <clock_start+0x188>)
    4bde:	4b31      	ldr	r3, [pc, #196]	; (4ca4 <clock_start+0x188>)
    4be0:	681b      	ldr	r3, [r3, #0]
    4be2:	f043 0301 	orr.w	r3, r3, #1
    4be6:	6013      	str	r3, [r2, #0]
	PLL0FEED_SEQUENCE;
    4be8:	4b2f      	ldr	r3, [pc, #188]	; (4ca8 <clock_start+0x18c>)
    4bea:	22aa      	movs	r2, #170	; 0xaa
    4bec:	601a      	str	r2, [r3, #0]
    4bee:	4b2e      	ldr	r3, [pc, #184]	; (4ca8 <clock_start+0x18c>)
    4bf0:	2255      	movs	r2, #85	; 0x55
    4bf2:	601a      	str	r2, [r3, #0]
	while (!(PLL0STAT & PLL0STAT_PLLE0_STAT));
    4bf4:	bf00      	nop
    4bf6:	4b2d      	ldr	r3, [pc, #180]	; (4cac <clock_start+0x190>)
    4bf8:	681b      	ldr	r3, [r3, #0]
    4bfa:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
    4bfe:	2b00      	cmp	r3, #0
    4c00:	d0f9      	beq.n	4bf6 <clock_start+0xda>

	/* set CPU clock divider */
	CCLKCFG = CCLKSEL;
    4c02:	4b2b      	ldr	r3, [pc, #172]	; (4cb0 <clock_start+0x194>)
    4c04:	2203      	movs	r2, #3
    4c06:	601a      	str	r2, [r3, #0]

	/* connect PLL0 */
	PLL0CON |= PLL0CON_PLLC0;
    4c08:	4a26      	ldr	r2, [pc, #152]	; (4ca4 <clock_start+0x188>)
    4c0a:	4b26      	ldr	r3, [pc, #152]	; (4ca4 <clock_start+0x188>)
    4c0c:	681b      	ldr	r3, [r3, #0]
    4c0e:	f043 0302 	orr.w	r3, r3, #2
    4c12:	6013      	str	r3, [r2, #0]
	PLL0FEED_SEQUENCE;
    4c14:	4b24      	ldr	r3, [pc, #144]	; (4ca8 <clock_start+0x18c>)
    4c16:	22aa      	movs	r2, #170	; 0xaa
    4c18:	601a      	str	r2, [r3, #0]
    4c1a:	4b23      	ldr	r3, [pc, #140]	; (4ca8 <clock_start+0x18c>)
    4c1c:	2255      	movs	r2, #85	; 0x55
    4c1e:	601a      	str	r2, [r3, #0]
	while (!(PLL0STAT & PLL0STAT_PLLC0_STAT));
    4c20:	bf00      	nop
    4c22:	4b22      	ldr	r3, [pc, #136]	; (4cac <clock_start+0x190>)
    4c24:	681b      	ldr	r3, [r3, #0]
    4c26:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
    4c2a:	2b00      	cmp	r3, #0
    4c2c:	d0f9      	beq.n	4c22 <clock_start+0x106>

	/* configure PLL1 */
	PLL1CFG = (MSEL1 << 0) | (PSEL1 << 5);
    4c2e:	4b26      	ldr	r3, [pc, #152]	; (4cc8 <clock_start+0x1ac>)
    4c30:	2222      	movs	r2, #34	; 0x22
    4c32:	601a      	str	r2, [r3, #0]
	PLL1FEED_SEQUENCE;
    4c34:	4b25      	ldr	r3, [pc, #148]	; (4ccc <clock_start+0x1b0>)
    4c36:	22aa      	movs	r2, #170	; 0xaa
    4c38:	601a      	str	r2, [r3, #0]
    4c3a:	4b24      	ldr	r3, [pc, #144]	; (4ccc <clock_start+0x1b0>)
    4c3c:	2255      	movs	r2, #85	; 0x55
    4c3e:	601a      	str	r2, [r3, #0]

	/* turn on PLL1 */
	PLL1CON |= PLL1CON_PLLE1;
    4c40:	4a23      	ldr	r2, [pc, #140]	; (4cd0 <clock_start+0x1b4>)
    4c42:	4b23      	ldr	r3, [pc, #140]	; (4cd0 <clock_start+0x1b4>)
    4c44:	681b      	ldr	r3, [r3, #0]
    4c46:	f043 0301 	orr.w	r3, r3, #1
    4c4a:	6013      	str	r3, [r2, #0]
	PLL1FEED_SEQUENCE;
    4c4c:	4b1f      	ldr	r3, [pc, #124]	; (4ccc <clock_start+0x1b0>)
    4c4e:	22aa      	movs	r2, #170	; 0xaa
    4c50:	601a      	str	r2, [r3, #0]
    4c52:	4b1e      	ldr	r3, [pc, #120]	; (4ccc <clock_start+0x1b0>)
    4c54:	2255      	movs	r2, #85	; 0x55
    4c56:	601a      	str	r2, [r3, #0]
	while (!(PLL1STAT & PLL1STAT_PLLE1_STAT));
    4c58:	bf00      	nop
    4c5a:	4b1e      	ldr	r3, [pc, #120]	; (4cd4 <clock_start+0x1b8>)
    4c5c:	681b      	ldr	r3, [r3, #0]
    4c5e:	f403 7380 	and.w	r3, r3, #256	; 0x100
    4c62:	2b00      	cmp	r3, #0
    4c64:	d0f9      	beq.n	4c5a <clock_start+0x13e>
	while (!(PLL1STAT & PLL1STAT_PLOCK1));
    4c66:	bf00      	nop
    4c68:	4b1a      	ldr	r3, [pc, #104]	; (4cd4 <clock_start+0x1b8>)
    4c6a:	681b      	ldr	r3, [r3, #0]
    4c6c:	f403 6380 	and.w	r3, r3, #1024	; 0x400
    4c70:	2b00      	cmp	r3, #0
    4c72:	d0f9      	beq.n	4c68 <clock_start+0x14c>

	/* connect PLL1 */
	PLL1CON |= PLL1CON_PLLC1;
    4c74:	4a16      	ldr	r2, [pc, #88]	; (4cd0 <clock_start+0x1b4>)
    4c76:	4b16      	ldr	r3, [pc, #88]	; (4cd0 <clock_start+0x1b4>)
    4c78:	681b      	ldr	r3, [r3, #0]
    4c7a:	f043 0302 	orr.w	r3, r3, #2
    4c7e:	6013      	str	r3, [r2, #0]
	PLL1FEED_SEQUENCE;
    4c80:	4b12      	ldr	r3, [pc, #72]	; (4ccc <clock_start+0x1b0>)
    4c82:	22aa      	movs	r2, #170	; 0xaa
    4c84:	601a      	str	r2, [r3, #0]
    4c86:	4b11      	ldr	r3, [pc, #68]	; (4ccc <clock_start+0x1b0>)
    4c88:	2255      	movs	r2, #85	; 0x55
    4c8a:	601a      	str	r2, [r3, #0]
	while (!(PLL1STAT & PLL1STAT_PLLC1_STAT));
    4c8c:	bf00      	nop
    4c8e:	4b11      	ldr	r3, [pc, #68]	; (4cd4 <clock_start+0x1b8>)
    4c90:	681b      	ldr	r3, [r3, #0]
    4c92:	f403 7300 	and.w	r3, r3, #512	; 0x200
    4c96:	2b00      	cmp	r3, #0
    4c98:	d0f9      	beq.n	4c8e <clock_start+0x172>
}
    4c9a:	bd80      	pop	{r7, pc}
    4c9c:	400fc000 	.word	0x400fc000
    4ca0:	400fc10c 	.word	0x400fc10c
    4ca4:	400fc080 	.word	0x400fc080
    4ca8:	400fc08c 	.word	0x400fc08c
    4cac:	400fc088 	.word	0x400fc088
    4cb0:	400fc104 	.word	0x400fc104
    4cb4:	400fc1a0 	.word	0x400fc1a0
    4cb8:	400fc1a8 	.word	0x400fc1a8
    4cbc:	400fc1ac 	.word	0x400fc1ac
    4cc0:	400fc084 	.word	0x400fc084
    4cc4:	00010018 	.word	0x00010018
    4cc8:	400fc0a4 	.word	0x400fc0a4
    4ccc:	400fc0ac 	.word	0x400fc0ac
    4cd0:	400fc0a0 	.word	0x400fc0a0
    4cd4:	400fc0a8 	.word	0x400fc0a8

00004cd8 <_HandleRequest>:
	@param [in,out]	ppbData		Data buffer.

	@return TRUE if the request was handles successfully
 */
static BOOL _HandleRequest(TSetupPacket *pSetup, int *piLen, U8 **ppbData)
{
    4cd8:	b580      	push	{r7, lr}
    4cda:	b088      	sub	sp, #32
    4cdc:	af00      	add	r7, sp, #0
    4cde:	60f8      	str	r0, [r7, #12]
    4ce0:	60b9      	str	r1, [r7, #8]
    4ce2:	607a      	str	r2, [r7, #4]
	TFnHandleRequest *pfnHandler;
	int iType;
	
	iType = REQTYPE_GET_TYPE(pSetup->bmRequestType);
    4ce4:	68fb      	ldr	r3, [r7, #12]
    4ce6:	781b      	ldrb	r3, [r3, #0]
    4ce8:	095b      	lsrs	r3, r3, #5
    4cea:	b2db      	uxtb	r3, r3
    4cec:	f003 0303 	and.w	r3, r3, #3
    4cf0:	61fb      	str	r3, [r7, #28]
	
	if(iType == REQTYPE_TYPE_VENDOR) {
    4cf2:	69fb      	ldr	r3, [r7, #28]
    4cf4:	2b02      	cmp	r3, #2
    4cf6:	d10e      	bne.n	4d16 <_HandleRequest+0x3e>
		BOOL fFilterStatus = FALSE;
    4cf8:	2300      	movs	r3, #0
    4cfa:	617b      	str	r3, [r7, #20]
		if(USBFilterOsVendorMessage(pSetup, &fFilterStatus, piLen, ppbData)) {
    4cfc:	f107 0314 	add.w	r3, r7, #20
    4d00:	68f8      	ldr	r0, [r7, #12]
    4d02:	4619      	mov	r1, r3
    4d04:	68ba      	ldr	r2, [r7, #8]
    4d06:	687b      	ldr	r3, [r7, #4]
    4d08:	f000 fce8 	bl	56dc <USBFilterOsVendorMessage>
    4d0c:	4603      	mov	r3, r0
    4d0e:	2b00      	cmp	r3, #0
    4d10:	d001      	beq.n	4d16 <_HandleRequest+0x3e>
			return fFilterStatus;
    4d12:	697b      	ldr	r3, [r7, #20]
    4d14:	e00f      	b.n	4d36 <_HandleRequest+0x5e>
		}
	}
	
	pfnHandler = apfnReqHandlers[iType];
    4d16:	4a0a      	ldr	r2, [pc, #40]	; (4d40 <_HandleRequest+0x68>)
    4d18:	69fb      	ldr	r3, [r7, #28]
    4d1a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    4d1e:	61bb      	str	r3, [r7, #24]
	if (pfnHandler == NULL) {
    4d20:	69bb      	ldr	r3, [r7, #24]
    4d22:	2b00      	cmp	r3, #0
    4d24:	d101      	bne.n	4d2a <_HandleRequest+0x52>
		DBG("No handler for reqtype %d\n", iType);
		return FALSE;
    4d26:	2300      	movs	r3, #0
    4d28:	e005      	b.n	4d36 <_HandleRequest+0x5e>
	}

	return pfnHandler(pSetup, piLen, ppbData);
    4d2a:	69bb      	ldr	r3, [r7, #24]
    4d2c:	68f8      	ldr	r0, [r7, #12]
    4d2e:	68b9      	ldr	r1, [r7, #8]
    4d30:	687a      	ldr	r2, [r7, #4]
    4d32:	4798      	blx	r3
    4d34:	4603      	mov	r3, r0
}
    4d36:	4618      	mov	r0, r3
    4d38:	3720      	adds	r7, #32
    4d3a:	46bd      	mov	sp, r7
    4d3c:	bd80      	pop	{r7, pc}
    4d3e:	bf00      	nop
    4d40:	10000698 	.word	0x10000698

00004d44 <StallControlPipe>:
	Local function to stall the control endpoint
	
	@param [in]	bEPStat	Endpoint status
 */
static void StallControlPipe(U8 bEPStat)
{
    4d44:	b580      	push	{r7, lr}
    4d46:	b084      	sub	sp, #16
    4d48:	af00      	add	r7, sp, #0
    4d4a:	4603      	mov	r3, r0
    4d4c:	71fb      	strb	r3, [r7, #7]
	U8	*pb;
	int	i;

	USBHwEPStall(0x80, TRUE);
    4d4e:	2080      	movs	r0, #128	; 0x80
    4d50:	2101      	movs	r1, #1
    4d52:	f000 fa99 	bl	5288 <USBHwEPStall>

// dump setup packet
	DBG("STALL on [");
	pb = (U8 *)&Setup;
    4d56:	4b07      	ldr	r3, [pc, #28]	; (4d74 <StallControlPipe+0x30>)
    4d58:	60bb      	str	r3, [r7, #8]
	for (i = 0; i < 8; i++) {
    4d5a:	2300      	movs	r3, #0
    4d5c:	60fb      	str	r3, [r7, #12]
    4d5e:	e002      	b.n	4d66 <StallControlPipe+0x22>
    4d60:	68fb      	ldr	r3, [r7, #12]
    4d62:	3301      	adds	r3, #1
    4d64:	60fb      	str	r3, [r7, #12]
    4d66:	68fb      	ldr	r3, [r7, #12]
    4d68:	2b07      	cmp	r3, #7
    4d6a:	ddf9      	ble.n	4d60 <StallControlPipe+0x1c>
		DBG(" %02x", *pb++);
	}
	DBG("] stat=%x\n", bEPStat);
}
    4d6c:	3710      	adds	r7, #16
    4d6e:	46bd      	mov	sp, r7
    4d70:	bd80      	pop	{r7, pc}
    4d72:	bf00      	nop
    4d74:	10000684 	.word	0x10000684

00004d78 <DataIn>:

/**
	Sends next chunk of data (possibly 0 bytes) to host
 */
static void DataIn(void)
{
    4d78:	b580      	push	{r7, lr}
    4d7a:	b082      	sub	sp, #8
    4d7c:	af00      	add	r7, sp, #0
	int iChunk;

	iChunk = MIN(MAX_PACKET_SIZE0, iResidue);
    4d7e:	4b0e      	ldr	r3, [pc, #56]	; (4db8 <DataIn+0x40>)
    4d80:	681b      	ldr	r3, [r3, #0]
    4d82:	2b40      	cmp	r3, #64	; 0x40
    4d84:	bfa8      	it	ge
    4d86:	2340      	movge	r3, #64	; 0x40
    4d88:	607b      	str	r3, [r7, #4]
	USBHwEPWrite(0x80, pbData, iChunk);
    4d8a:	4b0c      	ldr	r3, [pc, #48]	; (4dbc <DataIn+0x44>)
    4d8c:	681a      	ldr	r2, [r3, #0]
    4d8e:	687b      	ldr	r3, [r7, #4]
    4d90:	2080      	movs	r0, #128	; 0x80
    4d92:	4611      	mov	r1, r2
    4d94:	461a      	mov	r2, r3
    4d96:	f000 fa9b 	bl	52d0 <USBHwEPWrite>
	pbData += iChunk;
    4d9a:	4b08      	ldr	r3, [pc, #32]	; (4dbc <DataIn+0x44>)
    4d9c:	681a      	ldr	r2, [r3, #0]
    4d9e:	687b      	ldr	r3, [r7, #4]
    4da0:	4413      	add	r3, r2
    4da2:	4a06      	ldr	r2, [pc, #24]	; (4dbc <DataIn+0x44>)
    4da4:	6013      	str	r3, [r2, #0]
	iResidue -= iChunk;
    4da6:	4b04      	ldr	r3, [pc, #16]	; (4db8 <DataIn+0x40>)
    4da8:	681a      	ldr	r2, [r3, #0]
    4daa:	687b      	ldr	r3, [r7, #4]
    4dac:	1ad3      	subs	r3, r2, r3
    4dae:	4a02      	ldr	r2, [pc, #8]	; (4db8 <DataIn+0x40>)
    4db0:	6013      	str	r3, [r2, #0]
}
    4db2:	3708      	adds	r7, #8
    4db4:	46bd      	mov	sp, r7
    4db6:	bd80      	pop	{r7, pc}
    4db8:	10000690 	.word	0x10000690
    4dbc:	1000068c 	.word	0x1000068c

00004dc0 <USBHandleControlTransfer>:
 *
 *	@param [in]	bEP		Endpoint address
 *	@param [in]	bEPStat	Endpoint status
 */
void USBHandleControlTransfer(U8 bEP, U8 bEPStat)
{
    4dc0:	b580      	push	{r7, lr}
    4dc2:	b084      	sub	sp, #16
    4dc4:	af00      	add	r7, sp, #0
    4dc6:	4603      	mov	r3, r0
    4dc8:	460a      	mov	r2, r1
    4dca:	71fb      	strb	r3, [r7, #7]
    4dcc:	4613      	mov	r3, r2
    4dce:	71bb      	strb	r3, [r7, #6]
	int iChunk, iType;

	if (bEP == 0x00) {
    4dd0:	79fb      	ldrb	r3, [r7, #7]
    4dd2:	2b00      	cmp	r3, #0
    4dd4:	f040 8091 	bne.w	4efa <USBHandleControlTransfer+0x13a>
		// OUT transfer
		if (bEPStat & EP_STATUS_SETUP) {
    4dd8:	79bb      	ldrb	r3, [r7, #6]
    4dda:	f003 0304 	and.w	r3, r3, #4
    4dde:	2b00      	cmp	r3, #0
    4de0:	d041      	beq.n	4e66 <USBHandleControlTransfer+0xa6>
			// setup packet, reset request message state machine
			USBHwEPRead(0x00, (U8 *)&Setup, sizeof(Setup));
    4de2:	2000      	movs	r0, #0
    4de4:	4949      	ldr	r1, [pc, #292]	; (4f0c <USBHandleControlTransfer+0x14c>)
    4de6:	2208      	movs	r2, #8
    4de8:	f000 fac0 	bl	536c <USBHwEPRead>
			DBG("S%x", Setup.bRequest);

			// defaults for data pointer and residue
			iType = REQTYPE_GET_TYPE(Setup.bmRequestType);
    4dec:	4b47      	ldr	r3, [pc, #284]	; (4f0c <USBHandleControlTransfer+0x14c>)
    4dee:	781b      	ldrb	r3, [r3, #0]
    4df0:	095b      	lsrs	r3, r3, #5
    4df2:	b2db      	uxtb	r3, r3
    4df4:	f003 0303 	and.w	r3, r3, #3
    4df8:	60fb      	str	r3, [r7, #12]
			pbData = apbDataStore[iType];
    4dfa:	4a45      	ldr	r2, [pc, #276]	; (4f10 <USBHandleControlTransfer+0x150>)
    4dfc:	68fb      	ldr	r3, [r7, #12]
    4dfe:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    4e02:	4a44      	ldr	r2, [pc, #272]	; (4f14 <USBHandleControlTransfer+0x154>)
    4e04:	6013      	str	r3, [r2, #0]
			iResidue = Setup.wLength;
    4e06:	4b41      	ldr	r3, [pc, #260]	; (4f0c <USBHandleControlTransfer+0x14c>)
    4e08:	88db      	ldrh	r3, [r3, #6]
    4e0a:	461a      	mov	r2, r3
    4e0c:	4b42      	ldr	r3, [pc, #264]	; (4f18 <USBHandleControlTransfer+0x158>)
    4e0e:	601a      	str	r2, [r3, #0]
			iLen = Setup.wLength;
    4e10:	4b3e      	ldr	r3, [pc, #248]	; (4f0c <USBHandleControlTransfer+0x14c>)
    4e12:	88db      	ldrh	r3, [r3, #6]
    4e14:	461a      	mov	r2, r3
    4e16:	4b41      	ldr	r3, [pc, #260]	; (4f1c <USBHandleControlTransfer+0x15c>)
    4e18:	601a      	str	r2, [r3, #0]

			if ((Setup.wLength == 0) ||
    4e1a:	4b3c      	ldr	r3, [pc, #240]	; (4f0c <USBHandleControlTransfer+0x14c>)
    4e1c:	88db      	ldrh	r3, [r3, #6]
    4e1e:	2b00      	cmp	r3, #0
    4e20:	d007      	beq.n	4e32 <USBHandleControlTransfer+0x72>
				(REQTYPE_GET_DIR(Setup.bmRequestType) == REQTYPE_DIR_TO_HOST)) {
    4e22:	4b3a      	ldr	r3, [pc, #232]	; (4f0c <USBHandleControlTransfer+0x14c>)
    4e24:	781b      	ldrb	r3, [r3, #0]
    4e26:	09db      	lsrs	r3, r3, #7
    4e28:	b2db      	uxtb	r3, r3
    4e2a:	f003 0301 	and.w	r3, r3, #1
			iType = REQTYPE_GET_TYPE(Setup.bmRequestType);
			pbData = apbDataStore[iType];
			iResidue = Setup.wLength;
			iLen = Setup.wLength;

			if ((Setup.wLength == 0) ||
    4e2e:	2b00      	cmp	r3, #0
    4e30:	d068      	beq.n	4f04 <USBHandleControlTransfer+0x144>
				(REQTYPE_GET_DIR(Setup.bmRequestType) == REQTYPE_DIR_TO_HOST)) {
				// ask installed handler to process request
				if (!_HandleRequest(&Setup, &iLen, &pbData)) {
    4e32:	4836      	ldr	r0, [pc, #216]	; (4f0c <USBHandleControlTransfer+0x14c>)
    4e34:	4939      	ldr	r1, [pc, #228]	; (4f1c <USBHandleControlTransfer+0x15c>)
    4e36:	4a37      	ldr	r2, [pc, #220]	; (4f14 <USBHandleControlTransfer+0x154>)
    4e38:	f7ff ff4e 	bl	4cd8 <_HandleRequest>
    4e3c:	4603      	mov	r3, r0
    4e3e:	2b00      	cmp	r3, #0
    4e40:	d104      	bne.n	4e4c <USBHandleControlTransfer+0x8c>
					DBG("_HandleRequest1 failed\n");
					StallControlPipe(bEPStat);
    4e42:	79bb      	ldrb	r3, [r7, #6]
    4e44:	4618      	mov	r0, r3
    4e46:	f7ff ff7d 	bl	4d44 <StallControlPipe>
					return;
    4e4a:	e05b      	b.n	4f04 <USBHandleControlTransfer+0x144>
				}
				// send smallest of requested and offered length
				iResidue = MIN(iLen, Setup.wLength);
    4e4c:	4b2f      	ldr	r3, [pc, #188]	; (4f0c <USBHandleControlTransfer+0x14c>)
    4e4e:	88db      	ldrh	r3, [r3, #6]
    4e50:	461a      	mov	r2, r3
    4e52:	4b32      	ldr	r3, [pc, #200]	; (4f1c <USBHandleControlTransfer+0x15c>)
    4e54:	681b      	ldr	r3, [r3, #0]
    4e56:	4293      	cmp	r3, r2
    4e58:	bfa8      	it	ge
    4e5a:	4613      	movge	r3, r2
    4e5c:	4a2e      	ldr	r2, [pc, #184]	; (4f18 <USBHandleControlTransfer+0x158>)
    4e5e:	6013      	str	r3, [r2, #0]
				// send first part (possibly a zero-length status message)
				DataIn();
    4e60:	f7ff ff8a 	bl	4d78 <DataIn>
    4e64:	e04e      	b.n	4f04 <USBHandleControlTransfer+0x144>
			}
		}
		else {		
			if (iResidue > 0) {
    4e66:	4b2c      	ldr	r3, [pc, #176]	; (4f18 <USBHandleControlTransfer+0x158>)
    4e68:	681b      	ldr	r3, [r3, #0]
    4e6a:	2b00      	cmp	r3, #0
    4e6c:	dd3e      	ble.n	4eec <USBHandleControlTransfer+0x12c>
				// store data
				iChunk = USBHwEPRead(0x00, pbData, iResidue);
    4e6e:	4b29      	ldr	r3, [pc, #164]	; (4f14 <USBHandleControlTransfer+0x154>)
    4e70:	681a      	ldr	r2, [r3, #0]
    4e72:	4b29      	ldr	r3, [pc, #164]	; (4f18 <USBHandleControlTransfer+0x158>)
    4e74:	681b      	ldr	r3, [r3, #0]
    4e76:	2000      	movs	r0, #0
    4e78:	4611      	mov	r1, r2
    4e7a:	461a      	mov	r2, r3
    4e7c:	f000 fa76 	bl	536c <USBHwEPRead>
    4e80:	60b8      	str	r0, [r7, #8]
				if (iChunk < 0) {
    4e82:	68bb      	ldr	r3, [r7, #8]
    4e84:	2b00      	cmp	r3, #0
    4e86:	da04      	bge.n	4e92 <USBHandleControlTransfer+0xd2>
					StallControlPipe(bEPStat);
    4e88:	79bb      	ldrb	r3, [r7, #6]
    4e8a:	4618      	mov	r0, r3
    4e8c:	f7ff ff5a 	bl	4d44 <StallControlPipe>
					return;
    4e90:	e038      	b.n	4f04 <USBHandleControlTransfer+0x144>
				}
				pbData += iChunk;
    4e92:	4b20      	ldr	r3, [pc, #128]	; (4f14 <USBHandleControlTransfer+0x154>)
    4e94:	681a      	ldr	r2, [r3, #0]
    4e96:	68bb      	ldr	r3, [r7, #8]
    4e98:	4413      	add	r3, r2
    4e9a:	4a1e      	ldr	r2, [pc, #120]	; (4f14 <USBHandleControlTransfer+0x154>)
    4e9c:	6013      	str	r3, [r2, #0]
				iResidue -= iChunk;
    4e9e:	4b1e      	ldr	r3, [pc, #120]	; (4f18 <USBHandleControlTransfer+0x158>)
    4ea0:	681a      	ldr	r2, [r3, #0]
    4ea2:	68bb      	ldr	r3, [r7, #8]
    4ea4:	1ad3      	subs	r3, r2, r3
    4ea6:	4a1c      	ldr	r2, [pc, #112]	; (4f18 <USBHandleControlTransfer+0x158>)
    4ea8:	6013      	str	r3, [r2, #0]
				if (iResidue == 0) {
    4eaa:	4b1b      	ldr	r3, [pc, #108]	; (4f18 <USBHandleControlTransfer+0x158>)
    4eac:	681b      	ldr	r3, [r3, #0]
    4eae:	2b00      	cmp	r3, #0
    4eb0:	d128      	bne.n	4f04 <USBHandleControlTransfer+0x144>
					// received all, send data to handler
					iType = REQTYPE_GET_TYPE(Setup.bmRequestType);
    4eb2:	4b16      	ldr	r3, [pc, #88]	; (4f0c <USBHandleControlTransfer+0x14c>)
    4eb4:	781b      	ldrb	r3, [r3, #0]
    4eb6:	095b      	lsrs	r3, r3, #5
    4eb8:	b2db      	uxtb	r3, r3
    4eba:	f003 0303 	and.w	r3, r3, #3
    4ebe:	60fb      	str	r3, [r7, #12]
					pbData = apbDataStore[iType];
    4ec0:	4a13      	ldr	r2, [pc, #76]	; (4f10 <USBHandleControlTransfer+0x150>)
    4ec2:	68fb      	ldr	r3, [r7, #12]
    4ec4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    4ec8:	4a12      	ldr	r2, [pc, #72]	; (4f14 <USBHandleControlTransfer+0x154>)
    4eca:	6013      	str	r3, [r2, #0]
					if (!_HandleRequest(&Setup, &iLen, &pbData)) {
    4ecc:	480f      	ldr	r0, [pc, #60]	; (4f0c <USBHandleControlTransfer+0x14c>)
    4ece:	4913      	ldr	r1, [pc, #76]	; (4f1c <USBHandleControlTransfer+0x15c>)
    4ed0:	4a10      	ldr	r2, [pc, #64]	; (4f14 <USBHandleControlTransfer+0x154>)
    4ed2:	f7ff ff01 	bl	4cd8 <_HandleRequest>
    4ed6:	4603      	mov	r3, r0
    4ed8:	2b00      	cmp	r3, #0
    4eda:	d104      	bne.n	4ee6 <USBHandleControlTransfer+0x126>
						DBG("_HandleRequest2 failed\n");
						StallControlPipe(bEPStat);
    4edc:	79bb      	ldrb	r3, [r7, #6]
    4ede:	4618      	mov	r0, r3
    4ee0:	f7ff ff30 	bl	4d44 <StallControlPipe>
						return;
    4ee4:	e00e      	b.n	4f04 <USBHandleControlTransfer+0x144>
					}
					// send status to host
					DataIn();
    4ee6:	f7ff ff47 	bl	4d78 <DataIn>
    4eea:	e00b      	b.n	4f04 <USBHandleControlTransfer+0x144>
				}
			}
			else {
				// absorb zero-length status message
				iChunk = USBHwEPRead(0x00, NULL, 0);
    4eec:	2000      	movs	r0, #0
    4eee:	2100      	movs	r1, #0
    4ef0:	2200      	movs	r2, #0
    4ef2:	f000 fa3b 	bl	536c <USBHwEPRead>
    4ef6:	60b8      	str	r0, [r7, #8]
    4ef8:	e004      	b.n	4f04 <USBHandleControlTransfer+0x144>
				DBG(iChunk > 0 ? "?" : "");
			}
		}
	}
	else if (bEP == 0x80) {
    4efa:	79fb      	ldrb	r3, [r7, #7]
    4efc:	2b80      	cmp	r3, #128	; 0x80
    4efe:	d101      	bne.n	4f04 <USBHandleControlTransfer+0x144>
		// IN transfer
		// send more data if available (possibly a 0-length packet)
		DataIn();
    4f00:	f7ff ff3a 	bl	4d78 <DataIn>
	}
	else {
		ASSERT(FALSE);
	}
}
    4f04:	3710      	adds	r7, #16
    4f06:	46bd      	mov	sp, r7
    4f08:	bd80      	pop	{r7, pc}
    4f0a:	bf00      	nop
    4f0c:	10000684 	.word	0x10000684
    4f10:	100006a8 	.word	0x100006a8
    4f14:	1000068c 	.word	0x1000068c
    4f18:	10000690 	.word	0x10000690
    4f1c:	10000694 	.word	0x10000694

00004f20 <USBRegisterRequestHandler>:
	@param [in]	iType			Type of request, e.g. REQTYPE_TYPE_STANDARD
	@param [in]	*pfnHandler		Callback function pointer
	@param [in]	*pbDataStore	Data storage area for this type of request
 */
void USBRegisterRequestHandler(int iType, TFnHandleRequest *pfnHandler, U8 *pbDataStore)
{
    4f20:	b480      	push	{r7}
    4f22:	b085      	sub	sp, #20
    4f24:	af00      	add	r7, sp, #0
    4f26:	60f8      	str	r0, [r7, #12]
    4f28:	60b9      	str	r1, [r7, #8]
    4f2a:	607a      	str	r2, [r7, #4]
	ASSERT(iType >= 0);
	ASSERT(iType < 4);
	apfnReqHandlers[iType] = pfnHandler;
    4f2c:	4907      	ldr	r1, [pc, #28]	; (4f4c <USBRegisterRequestHandler+0x2c>)
    4f2e:	68fb      	ldr	r3, [r7, #12]
    4f30:	68ba      	ldr	r2, [r7, #8]
    4f32:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
	apbDataStore[iType] = pbDataStore;
    4f36:	4906      	ldr	r1, [pc, #24]	; (4f50 <USBRegisterRequestHandler+0x30>)
    4f38:	68fb      	ldr	r3, [r7, #12]
    4f3a:	687a      	ldr	r2, [r7, #4]
    4f3c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    4f40:	3714      	adds	r7, #20
    4f42:	46bd      	mov	sp, r7
    4f44:	f85d 7b04 	ldr.w	r7, [sp], #4
    4f48:	4770      	bx	lr
    4f4a:	bf00      	nop
    4f4c:	10000698 	.word	0x10000698
    4f50:	100006a8 	.word	0x100006a8

00004f54 <HandleUsbReset>:
	USB reset handler
	
	@param [in] bDevStatus	Device status
 */
static void HandleUsbReset(U8 bDevStatus)
{
    4f54:	b480      	push	{r7}
    4f56:	b083      	sub	sp, #12
    4f58:	af00      	add	r7, sp, #0
    4f5a:	4603      	mov	r3, r0
    4f5c:	71fb      	strb	r3, [r7, #7]
	if (bDevStatus & DEV_STATUS_RESET) {
		DBG("\n!");
	}
}
    4f5e:	370c      	adds	r7, #12
    4f60:	46bd      	mov	sp, r7
    4f62:	f85d 7b04 	ldr.w	r7, [sp], #4
    4f66:	4770      	bx	lr

00004f68 <USBInit>:
	installing default callbacks.
	
	@return TRUE if initialisation was successful
 */
BOOL USBInit(void)
{
    4f68:	b580      	push	{r7, lr}
    4f6a:	af00      	add	r7, sp, #0
	// init hardware
	USBHwInit();
    4f6c:	f000 fb40 	bl	55f0 <USBHwInit>
	
	// register bus reset handler
	USBHwRegisterDevIntHandler(HandleUsbReset);
    4f70:	480d      	ldr	r0, [pc, #52]	; (4fa8 <USBInit+0x40>)
    4f72:	f000 f913 	bl	519c <USBHwRegisterDevIntHandler>
	
	// register control transfer handler on EP0
	USBHwRegisterEPIntHandler(0x00, USBHandleControlTransfer);
    4f76:	2000      	movs	r0, #0
    4f78:	490c      	ldr	r1, [pc, #48]	; (4fac <USBInit+0x44>)
    4f7a:	f000 f8dd 	bl	5138 <USBHwRegisterEPIntHandler>
	USBHwRegisterEPIntHandler(0x80, USBHandleControlTransfer);
    4f7e:	2080      	movs	r0, #128	; 0x80
    4f80:	490a      	ldr	r1, [pc, #40]	; (4fac <USBInit+0x44>)
    4f82:	f000 f8d9 	bl	5138 <USBHwRegisterEPIntHandler>
	
	// setup control endpoints
	USBHwEPConfig(0x00, MAX_PACKET_SIZE0);
    4f86:	2000      	movs	r0, #0
    4f88:	2140      	movs	r1, #64	; 0x40
    4f8a:	f000 f8b7 	bl	50fc <USBHwEPConfig>
	USBHwEPConfig(0x80, MAX_PACKET_SIZE0);
    4f8e:	2080      	movs	r0, #128	; 0x80
    4f90:	2140      	movs	r1, #64	; 0x40
    4f92:	f000 f8b3 	bl	50fc <USBHwEPConfig>
	
	// register standard request handler
	USBRegisterRequestHandler(REQTYPE_TYPE_STANDARD, USBHandleStandardRequest, abStdReqData);
    4f96:	2000      	movs	r0, #0
    4f98:	4905      	ldr	r1, [pc, #20]	; (4fb0 <USBInit+0x48>)
    4f9a:	4a06      	ldr	r2, [pc, #24]	; (4fb4 <USBInit+0x4c>)
    4f9c:	f7ff ffc0 	bl	4f20 <USBRegisterRequestHandler>

	return TRUE;
    4fa0:	2301      	movs	r3, #1
}
    4fa2:	4618      	mov	r0, r3
    4fa4:	bd80      	pop	{r7, pc}
    4fa6:	bf00      	nop
    4fa8:	00004f55 	.word	0x00004f55
    4fac:	00004dc1 	.word	0x00004dc1
    4fb0:	00005bb1 	.word	0x00005bb1
    4fb4:	100006b8 	.word	0x100006b8

00004fb8 <Wait4DevInt>:
    Local function to wait for a device interrupt (and clear it)
        
    @param [in] dwIntr      Bitmask of interrupts to wait for   
 */
static void Wait4DevInt(U32 dwIntr)
{
    4fb8:	b480      	push	{r7}
    4fba:	b083      	sub	sp, #12
    4fbc:	af00      	add	r7, sp, #0
    4fbe:	6078      	str	r0, [r7, #4]
    // wait for specific interrupt
    while ((USBDevIntSt & dwIntr) != dwIntr);
    4fc0:	bf00      	nop
    4fc2:	4b07      	ldr	r3, [pc, #28]	; (4fe0 <Wait4DevInt+0x28>)
    4fc4:	681a      	ldr	r2, [r3, #0]
    4fc6:	687b      	ldr	r3, [r7, #4]
    4fc8:	401a      	ands	r2, r3
    4fca:	687b      	ldr	r3, [r7, #4]
    4fcc:	429a      	cmp	r2, r3
    4fce:	d1f8      	bne.n	4fc2 <Wait4DevInt+0xa>
    // clear the interrupt bits
    USBDevIntClr = dwIntr;
    4fd0:	4a04      	ldr	r2, [pc, #16]	; (4fe4 <Wait4DevInt+0x2c>)
    4fd2:	687b      	ldr	r3, [r7, #4]
    4fd4:	6013      	str	r3, [r2, #0]
}
    4fd6:	370c      	adds	r7, #12
    4fd8:	46bd      	mov	sp, r7
    4fda:	f85d 7b04 	ldr.w	r7, [sp], #4
    4fde:	4770      	bx	lr
    4fe0:	5000c200 	.word	0x5000c200
    4fe4:	5000c208 	.word	0x5000c208

00004fe8 <USBHwCmd>:
    Local function to send a command to the USB protocol engine
        
    @param [in] bCmd        Command to send
 */
static void USBHwCmd(U8 bCmd)
{
    4fe8:	b580      	push	{r7, lr}
    4fea:	b082      	sub	sp, #8
    4fec:	af00      	add	r7, sp, #0
    4fee:	4603      	mov	r3, r0
    4ff0:	71fb      	strb	r3, [r7, #7]
    // clear CDFULL/CCEMTY
    USBDevIntClr = CDFULL | CCEMTY;
    4ff2:	4b07      	ldr	r3, [pc, #28]	; (5010 <USBHwCmd+0x28>)
    4ff4:	2230      	movs	r2, #48	; 0x30
    4ff6:	601a      	str	r2, [r3, #0]
    // write command code
    USBCmdCode = 0x00000500 | (bCmd << 16);
    4ff8:	4a06      	ldr	r2, [pc, #24]	; (5014 <USBHwCmd+0x2c>)
    4ffa:	79fb      	ldrb	r3, [r7, #7]
    4ffc:	041b      	lsls	r3, r3, #16
    4ffe:	f443 63a0 	orr.w	r3, r3, #1280	; 0x500
    5002:	6013      	str	r3, [r2, #0]
    Wait4DevInt(CCEMTY);
    5004:	2010      	movs	r0, #16
    5006:	f7ff ffd7 	bl	4fb8 <Wait4DevInt>
}
    500a:	3708      	adds	r7, #8
    500c:	46bd      	mov	sp, r7
    500e:	bd80      	pop	{r7, pc}
    5010:	5000c208 	.word	0x5000c208
    5014:	5000c210 	.word	0x5000c210

00005018 <USBHwCmdWrite>:
        
    @param [in] bCmd        Command to send
    @param [in] bData       Data to send
 */
static void USBHwCmdWrite(U8 bCmd, U16 bData)
{
    5018:	b580      	push	{r7, lr}
    501a:	b082      	sub	sp, #8
    501c:	af00      	add	r7, sp, #0
    501e:	4603      	mov	r3, r0
    5020:	460a      	mov	r2, r1
    5022:	71fb      	strb	r3, [r7, #7]
    5024:	4613      	mov	r3, r2
    5026:	80bb      	strh	r3, [r7, #4]
    // write command code
    USBHwCmd(bCmd);
    5028:	79fb      	ldrb	r3, [r7, #7]
    502a:	4618      	mov	r0, r3
    502c:	f7ff ffdc 	bl	4fe8 <USBHwCmd>

    // write command data
    USBCmdCode = 0x00000100 | (bData << 16);
    5030:	4a05      	ldr	r2, [pc, #20]	; (5048 <USBHwCmdWrite+0x30>)
    5032:	88bb      	ldrh	r3, [r7, #4]
    5034:	041b      	lsls	r3, r3, #16
    5036:	f443 7380 	orr.w	r3, r3, #256	; 0x100
    503a:	6013      	str	r3, [r2, #0]
    Wait4DevInt(CCEMTY);
    503c:	2010      	movs	r0, #16
    503e:	f7ff ffbb 	bl	4fb8 <Wait4DevInt>
}
    5042:	3708      	adds	r7, #8
    5044:	46bd      	mov	sp, r7
    5046:	bd80      	pop	{r7, pc}
    5048:	5000c210 	.word	0x5000c210

0000504c <USBHwCmdRead>:
    @param [in] bCmd        Command to send

    @return the data
 */
static U8 USBHwCmdRead(U8 bCmd)
{
    504c:	b580      	push	{r7, lr}
    504e:	b082      	sub	sp, #8
    5050:	af00      	add	r7, sp, #0
    5052:	4603      	mov	r3, r0
    5054:	71fb      	strb	r3, [r7, #7]
    // write command code
    USBHwCmd(bCmd);
    5056:	79fb      	ldrb	r3, [r7, #7]
    5058:	4618      	mov	r0, r3
    505a:	f7ff ffc5 	bl	4fe8 <USBHwCmd>
    
    // get data
    USBCmdCode = 0x00000200 | (bCmd << 16);
    505e:	4a08      	ldr	r2, [pc, #32]	; (5080 <USBHwCmdRead+0x34>)
    5060:	79fb      	ldrb	r3, [r7, #7]
    5062:	041b      	lsls	r3, r3, #16
    5064:	f443 7300 	orr.w	r3, r3, #512	; 0x200
    5068:	6013      	str	r3, [r2, #0]
    Wait4DevInt(CDFULL);
    506a:	2020      	movs	r0, #32
    506c:	f7ff ffa4 	bl	4fb8 <Wait4DevInt>
    return USBCmdData;
    5070:	4b04      	ldr	r3, [pc, #16]	; (5084 <USBHwCmdRead+0x38>)
    5072:	681b      	ldr	r3, [r3, #0]
    5074:	b2db      	uxtb	r3, r3
}
    5076:	4618      	mov	r0, r3
    5078:	3708      	adds	r7, #8
    507a:	46bd      	mov	sp, r7
    507c:	bd80      	pop	{r7, pc}
    507e:	bf00      	nop
    5080:	5000c210 	.word	0x5000c210
    5084:	5000c214 	.word	0x5000c214

00005088 <USBHwEPRealize>:
        
    @param [in] idx         Endpoint index
    @param [in] wMaxPSize   Maximum packet size for this endpoint
 */
static void USBHwEPRealize(int idx, U16 wMaxPSize)
{
    5088:	b580      	push	{r7, lr}
    508a:	b082      	sub	sp, #8
    508c:	af00      	add	r7, sp, #0
    508e:	6078      	str	r0, [r7, #4]
    5090:	460b      	mov	r3, r1
    5092:	807b      	strh	r3, [r7, #2]
    USBReEp |= (1 << idx);
    5094:	490a      	ldr	r1, [pc, #40]	; (50c0 <USBHwEPRealize+0x38>)
    5096:	4b0a      	ldr	r3, [pc, #40]	; (50c0 <USBHwEPRealize+0x38>)
    5098:	681b      	ldr	r3, [r3, #0]
    509a:	2001      	movs	r0, #1
    509c:	687a      	ldr	r2, [r7, #4]
    509e:	fa00 f202 	lsl.w	r2, r0, r2
    50a2:	4313      	orrs	r3, r2
    50a4:	600b      	str	r3, [r1, #0]
#ifdef LPC17xx
    USBEpIn = idx;
    50a6:	4a07      	ldr	r2, [pc, #28]	; (50c4 <USBHwEPRealize+0x3c>)
    50a8:	687b      	ldr	r3, [r7, #4]
    50aa:	6013      	str	r3, [r2, #0]
#else
    USBEpInd = idx;
#endif
    USBMaxPSize = wMaxPSize;
    50ac:	4a06      	ldr	r2, [pc, #24]	; (50c8 <USBHwEPRealize+0x40>)
    50ae:	887b      	ldrh	r3, [r7, #2]
    50b0:	6013      	str	r3, [r2, #0]
    Wait4DevInt(EP_RLZED);
    50b2:	f44f 7080 	mov.w	r0, #256	; 0x100
    50b6:	f7ff ff7f 	bl	4fb8 <Wait4DevInt>
}
    50ba:	3708      	adds	r7, #8
    50bc:	46bd      	mov	sp, r7
    50be:	bd80      	pop	{r7, pc}
    50c0:	5000c244 	.word	0x5000c244
    50c4:	5000c248 	.word	0x5000c248
    50c8:	5000c24c 	.word	0x5000c24c

000050cc <USBHwEPEnable>:
        
    @param [in] idx     Endpoint index
    @param [in] fEnable TRUE to enable, FALSE to disable
 */
static void USBHwEPEnable(int idx, BOOL fEnable)
{
    50cc:	b580      	push	{r7, lr}
    50ce:	b082      	sub	sp, #8
    50d0:	af00      	add	r7, sp, #0
    50d2:	6078      	str	r0, [r7, #4]
    50d4:	6039      	str	r1, [r7, #0]
    USBHwCmdWrite(CMD_EP_SET_STATUS | idx, fEnable ? 0 : EP_DA);
    50d6:	687b      	ldr	r3, [r7, #4]
    50d8:	b2db      	uxtb	r3, r3
    50da:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    50de:	b2db      	uxtb	r3, r3
    50e0:	b2da      	uxtb	r2, r3
    50e2:	683b      	ldr	r3, [r7, #0]
    50e4:	2b00      	cmp	r3, #0
    50e6:	d001      	beq.n	50ec <USBHwEPEnable+0x20>
    50e8:	2300      	movs	r3, #0
    50ea:	e000      	b.n	50ee <USBHwEPEnable+0x22>
    50ec:	2320      	movs	r3, #32
    50ee:	4610      	mov	r0, r2
    50f0:	4619      	mov	r1, r3
    50f2:	f7ff ff91 	bl	5018 <USBHwCmdWrite>
}
    50f6:	3708      	adds	r7, #8
    50f8:	46bd      	mov	sp, r7
    50fa:	bd80      	pop	{r7, pc}

000050fc <USBHwEPConfig>:
        
    @param [in] bEP             Endpoint number
    @param [in] wMaxPacketSize  Maximum packet size for this EP
 */
void USBHwEPConfig(U8 bEP, U16 wMaxPacketSize)
{
    50fc:	b580      	push	{r7, lr}
    50fe:	b084      	sub	sp, #16
    5100:	af00      	add	r7, sp, #0
    5102:	4603      	mov	r3, r0
    5104:	460a      	mov	r2, r1
    5106:	71fb      	strb	r3, [r7, #7]
    5108:	4613      	mov	r3, r2
    510a:	80bb      	strh	r3, [r7, #4]
    int idx;
    
    idx = EP2IDX(bEP);
    510c:	79fb      	ldrb	r3, [r7, #7]
    510e:	f003 030f 	and.w	r3, r3, #15
    5112:	005b      	lsls	r3, r3, #1
    5114:	79fa      	ldrb	r2, [r7, #7]
    5116:	09d2      	lsrs	r2, r2, #7
    5118:	b2d2      	uxtb	r2, r2
    511a:	4313      	orrs	r3, r2
    511c:	60fb      	str	r3, [r7, #12]
    
    // realise EP
    USBHwEPRealize(idx, wMaxPacketSize);
    511e:	88bb      	ldrh	r3, [r7, #4]
    5120:	68f8      	ldr	r0, [r7, #12]
    5122:	4619      	mov	r1, r3
    5124:	f7ff ffb0 	bl	5088 <USBHwEPRealize>

    // enable EP
    USBHwEPEnable(idx, TRUE);
    5128:	68f8      	ldr	r0, [r7, #12]
    512a:	2101      	movs	r1, #1
    512c:	f7ff ffce 	bl	50cc <USBHwEPEnable>
}
    5130:	3710      	adds	r7, #16
    5132:	46bd      	mov	sp, r7
    5134:	bd80      	pop	{r7, pc}
    5136:	bf00      	nop

00005138 <USBHwRegisterEPIntHandler>:
        
    @param [in] bEP             Endpoint number
    @param [in] pfnHandler      Callback function
 */
void USBHwRegisterEPIntHandler(U8 bEP, TFnEPIntHandler *pfnHandler)
{
    5138:	b480      	push	{r7}
    513a:	b085      	sub	sp, #20
    513c:	af00      	add	r7, sp, #0
    513e:	4603      	mov	r3, r0
    5140:	6039      	str	r1, [r7, #0]
    5142:	71fb      	strb	r3, [r7, #7]
    int idx;
    
    idx = EP2IDX(bEP);
    5144:	79fb      	ldrb	r3, [r7, #7]
    5146:	f003 030f 	and.w	r3, r3, #15
    514a:	005b      	lsls	r3, r3, #1
    514c:	79fa      	ldrb	r2, [r7, #7]
    514e:	09d2      	lsrs	r2, r2, #7
    5150:	b2d2      	uxtb	r2, r2
    5152:	4313      	orrs	r3, r2
    5154:	60fb      	str	r3, [r7, #12]

    ASSERT(idx<32);

    /* add handler to list of EP handlers */
    _apfnEPIntHandlers[idx / 2] = pfnHandler;
    5156:	68fb      	ldr	r3, [r7, #12]
    5158:	0fda      	lsrs	r2, r3, #31
    515a:	4413      	add	r3, r2
    515c:	105b      	asrs	r3, r3, #1
    515e:	4619      	mov	r1, r3
    5160:	4a0b      	ldr	r2, [pc, #44]	; (5190 <USBHwRegisterEPIntHandler+0x58>)
    5162:	683b      	ldr	r3, [r7, #0]
    5164:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
    
    /* enable EP interrupt */
    USBEpIntEn |= (1 << idx);
    5168:	490a      	ldr	r1, [pc, #40]	; (5194 <USBHwRegisterEPIntHandler+0x5c>)
    516a:	4b0a      	ldr	r3, [pc, #40]	; (5194 <USBHwRegisterEPIntHandler+0x5c>)
    516c:	681b      	ldr	r3, [r3, #0]
    516e:	2001      	movs	r0, #1
    5170:	68fa      	ldr	r2, [r7, #12]
    5172:	fa00 f202 	lsl.w	r2, r0, r2
    5176:	4313      	orrs	r3, r2
    5178:	600b      	str	r3, [r1, #0]
    USBDevIntEn |= EP_SLOW;
    517a:	4a07      	ldr	r2, [pc, #28]	; (5198 <USBHwRegisterEPIntHandler+0x60>)
    517c:	4b06      	ldr	r3, [pc, #24]	; (5198 <USBHwRegisterEPIntHandler+0x60>)
    517e:	681b      	ldr	r3, [r3, #0]
    5180:	f043 0304 	orr.w	r3, r3, #4
    5184:	6013      	str	r3, [r2, #0]
    
    DBG("Registered handler for EP 0x%x\n", bEP);
}
    5186:	3714      	adds	r7, #20
    5188:	46bd      	mov	sp, r7
    518a:	f85d 7b04 	ldr.w	r7, [sp], #4
    518e:	4770      	bx	lr
    5190:	100006c4 	.word	0x100006c4
    5194:	5000c234 	.word	0x5000c234
    5198:	5000c204 	.word	0x5000c204

0000519c <USBHwRegisterDevIntHandler>:
    Registers an device status callback
        
    @param [in] pfnHandler  Callback function
 */
void USBHwRegisterDevIntHandler(TFnDevIntHandler *pfnHandler)
{
    519c:	b480      	push	{r7}
    519e:	b083      	sub	sp, #12
    51a0:	af00      	add	r7, sp, #0
    51a2:	6078      	str	r0, [r7, #4]
    _pfnDevIntHandler = pfnHandler;
    51a4:	4a06      	ldr	r2, [pc, #24]	; (51c0 <USBHwRegisterDevIntHandler+0x24>)
    51a6:	687b      	ldr	r3, [r7, #4]
    51a8:	6013      	str	r3, [r2, #0]
    
    // enable device interrupt
    USBDevIntEn |= DEV_STAT;
    51aa:	4a06      	ldr	r2, [pc, #24]	; (51c4 <USBHwRegisterDevIntHandler+0x28>)
    51ac:	4b05      	ldr	r3, [pc, #20]	; (51c4 <USBHwRegisterDevIntHandler+0x28>)
    51ae:	681b      	ldr	r3, [r3, #0]
    51b0:	f043 0308 	orr.w	r3, r3, #8
    51b4:	6013      	str	r3, [r2, #0]

    DBG("Registered handler for device status\n");
}
    51b6:	370c      	adds	r7, #12
    51b8:	46bd      	mov	sp, r7
    51ba:	f85d 7b04 	ldr.w	r7, [sp], #4
    51be:	4770      	bx	lr
    51c0:	100006c0 	.word	0x100006c0
    51c4:	5000c204 	.word	0x5000c204

000051c8 <USBHwRegisterFrameHandler>:
    Registers the frame callback
        
    @param [in] pfnHandler  Callback function
 */
void USBHwRegisterFrameHandler(TFnFrameHandler *pfnHandler)
{
    51c8:	b480      	push	{r7}
    51ca:	b083      	sub	sp, #12
    51cc:	af00      	add	r7, sp, #0
    51ce:	6078      	str	r0, [r7, #4]
    _pfnFrameHandler = pfnHandler;
    51d0:	4a06      	ldr	r2, [pc, #24]	; (51ec <USBHwRegisterFrameHandler+0x24>)
    51d2:	687b      	ldr	r3, [r7, #4]
    51d4:	6013      	str	r3, [r2, #0]
    
    // enable device interrupt
    USBDevIntEn |= FRAME;
    51d6:	4a06      	ldr	r2, [pc, #24]	; (51f0 <USBHwRegisterFrameHandler+0x28>)
    51d8:	4b05      	ldr	r3, [pc, #20]	; (51f0 <USBHwRegisterFrameHandler+0x28>)
    51da:	681b      	ldr	r3, [r3, #0]
    51dc:	f043 0301 	orr.w	r3, r3, #1
    51e0:	6013      	str	r3, [r2, #0]

    DBG("Registered handler for frame\n");
}
    51e2:	370c      	adds	r7, #12
    51e4:	46bd      	mov	sp, r7
    51e6:	f85d 7b04 	ldr.w	r7, [sp], #4
    51ea:	4770      	bx	lr
    51ec:	10000704 	.word	0x10000704
    51f0:	5000c204 	.word	0x5000c204

000051f4 <USBHwSetAddress>:
    Sets the USB address.
        
    @param [in] bAddr       Device address to set
 */
void USBHwSetAddress(U8 bAddr)
{
    51f4:	b580      	push	{r7, lr}
    51f6:	b082      	sub	sp, #8
    51f8:	af00      	add	r7, sp, #0
    51fa:	4603      	mov	r3, r0
    51fc:	71fb      	strb	r3, [r7, #7]
    USBHwCmdWrite(CMD_DEV_SET_ADDRESS, DEV_EN | bAddr);
    51fe:	79fb      	ldrb	r3, [r7, #7]
    5200:	f063 037f 	orn	r3, r3, #127	; 0x7f
    5204:	b2db      	uxtb	r3, r3
    5206:	b29b      	uxth	r3, r3
    5208:	20d0      	movs	r0, #208	; 0xd0
    520a:	4619      	mov	r1, r3
    520c:	f7ff ff04 	bl	5018 <USBHwCmdWrite>
}
    5210:	3708      	adds	r7, #8
    5212:	46bd      	mov	sp, r7
    5214:	bd80      	pop	{r7, pc}
    5216:	bf00      	nop

00005218 <USBHwConnect>:
    Connects or disconnects from the USB bus
        
    @param [in] fConnect    If TRUE, connect, otherwise disconnect
 */
void USBHwConnect(BOOL fConnect)
{
    5218:	b580      	push	{r7, lr}
    521a:	b082      	sub	sp, #8
    521c:	af00      	add	r7, sp, #0
    521e:	6078      	str	r0, [r7, #4]
    FIO0CLR = (1<<14);
  else
    FIO0SET = (1<<14);
#endif
#endif
    USBHwCmdWrite(CMD_DEV_STATUS, fConnect ? CON : 0);
    5220:	687b      	ldr	r3, [r7, #4]
    5222:	2b00      	cmp	r3, #0
    5224:	bf14      	ite	ne
    5226:	2301      	movne	r3, #1
    5228:	2300      	moveq	r3, #0
    522a:	b2db      	uxtb	r3, r3
    522c:	b29b      	uxth	r3, r3
    522e:	20fe      	movs	r0, #254	; 0xfe
    5230:	4619      	mov	r1, r3
    5232:	f7ff fef1 	bl	5018 <USBHwCmdWrite>
}
    5236:	3708      	adds	r7, #8
    5238:	46bd      	mov	sp, r7
    523a:	bd80      	pop	{r7, pc}

0000523c <USBHwNakIntEnable>:
    from NAK interrupt by checking the bits in their bEPStatus argument.
    
    @param [in] bIntBits    Bitmap indicating which NAK interrupts to enable
 */
void USBHwNakIntEnable(U8 bIntBits)
{
    523c:	b580      	push	{r7, lr}
    523e:	b082      	sub	sp, #8
    5240:	af00      	add	r7, sp, #0
    5242:	4603      	mov	r3, r0
    5244:	71fb      	strb	r3, [r7, #7]
    USBHwCmdWrite(CMD_DEV_SET_MODE, bIntBits);
    5246:	79fb      	ldrb	r3, [r7, #7]
    5248:	b29b      	uxth	r3, r3
    524a:	20f3      	movs	r0, #243	; 0xf3
    524c:	4619      	mov	r1, r3
    524e:	f7ff fee3 	bl	5018 <USBHwCmdWrite>
}
    5252:	3708      	adds	r7, #8
    5254:	46bd      	mov	sp, r7
    5256:	bd80      	pop	{r7, pc}

00005258 <USBHwEPGetStatus>:
        
    @param [in] bEP     Endpoint number
    @return Endpoint status byte (containing EP_STATUS_xxx bits)
 */
U8  USBHwEPGetStatus(U8 bEP)
{
    5258:	b580      	push	{r7, lr}
    525a:	b084      	sub	sp, #16
    525c:	af00      	add	r7, sp, #0
    525e:	4603      	mov	r3, r0
    5260:	71fb      	strb	r3, [r7, #7]
    int idx = EP2IDX(bEP);
    5262:	79fb      	ldrb	r3, [r7, #7]
    5264:	f003 030f 	and.w	r3, r3, #15
    5268:	005b      	lsls	r3, r3, #1
    526a:	79fa      	ldrb	r2, [r7, #7]
    526c:	09d2      	lsrs	r2, r2, #7
    526e:	b2d2      	uxtb	r2, r2
    5270:	4313      	orrs	r3, r2
    5272:	60fb      	str	r3, [r7, #12]

    return USBHwCmdRead(CMD_EP_SELECT | idx);
    5274:	68fb      	ldr	r3, [r7, #12]
    5276:	b2db      	uxtb	r3, r3
    5278:	4618      	mov	r0, r3
    527a:	f7ff fee7 	bl	504c <USBHwCmdRead>
    527e:	4603      	mov	r3, r0
}
    5280:	4618      	mov	r0, r3
    5282:	3710      	adds	r7, #16
    5284:	46bd      	mov	sp, r7
    5286:	bd80      	pop	{r7, pc}

00005288 <USBHwEPStall>:
        
    @param [in] bEP     Endpoint number
    @param [in] fStall  TRUE to stall, FALSE to unstall
 */
void USBHwEPStall(U8 bEP, BOOL fStall)
{
    5288:	b580      	push	{r7, lr}
    528a:	b084      	sub	sp, #16
    528c:	af00      	add	r7, sp, #0
    528e:	4603      	mov	r3, r0
    5290:	6039      	str	r1, [r7, #0]
    5292:	71fb      	strb	r3, [r7, #7]
    int idx = EP2IDX(bEP);
    5294:	79fb      	ldrb	r3, [r7, #7]
    5296:	f003 030f 	and.w	r3, r3, #15
    529a:	005b      	lsls	r3, r3, #1
    529c:	79fa      	ldrb	r2, [r7, #7]
    529e:	09d2      	lsrs	r2, r2, #7
    52a0:	b2d2      	uxtb	r2, r2
    52a2:	4313      	orrs	r3, r2
    52a4:	60fb      	str	r3, [r7, #12]

    USBHwCmdWrite(CMD_EP_SET_STATUS | idx, fStall ? EP_ST : 0);
    52a6:	68fb      	ldr	r3, [r7, #12]
    52a8:	b2db      	uxtb	r3, r3
    52aa:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    52ae:	b2db      	uxtb	r3, r3
    52b0:	b2da      	uxtb	r2, r3
    52b2:	683b      	ldr	r3, [r7, #0]
    52b4:	2b00      	cmp	r3, #0
    52b6:	bf14      	ite	ne
    52b8:	2301      	movne	r3, #1
    52ba:	2300      	moveq	r3, #0
    52bc:	b2db      	uxtb	r3, r3
    52be:	b29b      	uxth	r3, r3
    52c0:	4610      	mov	r0, r2
    52c2:	4619      	mov	r1, r3
    52c4:	f7ff fea8 	bl	5018 <USBHwCmdWrite>
}
    52c8:	3710      	adds	r7, #16
    52ca:	46bd      	mov	sp, r7
    52cc:	bd80      	pop	{r7, pc}
    52ce:	bf00      	nop

000052d0 <USBHwEPWrite>:
    @param [in] iLen    Number of bytes to write
            
    @return number of bytes written into the endpoint buffer
*/
int USBHwEPWrite(U8 bEP, U8 *pbBuf, U32 iLen)
{
    52d0:	b580      	push	{r7, lr}
    52d2:	b086      	sub	sp, #24
    52d4:	af00      	add	r7, sp, #0
    52d6:	4603      	mov	r3, r0
    52d8:	60b9      	str	r1, [r7, #8]
    52da:	607a      	str	r2, [r7, #4]
    52dc:	73fb      	strb	r3, [r7, #15]
    U32 idx;
    
    idx = EP2IDX(bEP);
    52de:	7bfb      	ldrb	r3, [r7, #15]
    52e0:	f003 030f 	and.w	r3, r3, #15
    52e4:	005b      	lsls	r3, r3, #1
    52e6:	7bfa      	ldrb	r2, [r7, #15]
    52e8:	09d2      	lsrs	r2, r2, #7
    52ea:	b2d2      	uxtb	r2, r2
    52ec:	4313      	orrs	r3, r2
    52ee:	617b      	str	r3, [r7, #20]
    
    // set write enable for specific endpoint
    USBCtrl = WR_EN | ((bEP & 0xF) << 2);
    52f0:	4a1b      	ldr	r2, [pc, #108]	; (5360 <USBHwEPWrite+0x90>)
    52f2:	7bfb      	ldrb	r3, [r7, #15]
    52f4:	f003 030f 	and.w	r3, r3, #15
    52f8:	009b      	lsls	r3, r3, #2
    52fa:	f043 0302 	orr.w	r3, r3, #2
    52fe:	6013      	str	r3, [r2, #0]
    
    // set packet length
    USBTxPLen = iLen;
    5300:	4a18      	ldr	r2, [pc, #96]	; (5364 <USBHwEPWrite+0x94>)
    5302:	687b      	ldr	r3, [r7, #4]
    5304:	6013      	str	r3, [r2, #0]
    
    // write data
    while (USBCtrl & WR_EN) {
    5306:	e015      	b.n	5334 <USBHwEPWrite+0x64>
        USBTxData = (pbBuf[3] << 24) | (pbBuf[2] << 16) | (pbBuf[1] << 8) | pbBuf[0];
    5308:	4917      	ldr	r1, [pc, #92]	; (5368 <USBHwEPWrite+0x98>)
    530a:	68bb      	ldr	r3, [r7, #8]
    530c:	3303      	adds	r3, #3
    530e:	781b      	ldrb	r3, [r3, #0]
    5310:	061a      	lsls	r2, r3, #24
    5312:	68bb      	ldr	r3, [r7, #8]
    5314:	3302      	adds	r3, #2
    5316:	781b      	ldrb	r3, [r3, #0]
    5318:	041b      	lsls	r3, r3, #16
    531a:	431a      	orrs	r2, r3
    531c:	68bb      	ldr	r3, [r7, #8]
    531e:	3301      	adds	r3, #1
    5320:	781b      	ldrb	r3, [r3, #0]
    5322:	021b      	lsls	r3, r3, #8
    5324:	4313      	orrs	r3, r2
    5326:	68ba      	ldr	r2, [r7, #8]
    5328:	7812      	ldrb	r2, [r2, #0]
    532a:	4313      	orrs	r3, r2
    532c:	600b      	str	r3, [r1, #0]
        pbBuf += 4;
    532e:	68bb      	ldr	r3, [r7, #8]
    5330:	3304      	adds	r3, #4
    5332:	60bb      	str	r3, [r7, #8]
    
    // set packet length
    USBTxPLen = iLen;
    
    // write data
    while (USBCtrl & WR_EN) {
    5334:	4b0a      	ldr	r3, [pc, #40]	; (5360 <USBHwEPWrite+0x90>)
    5336:	681b      	ldr	r3, [r3, #0]
    5338:	f003 0302 	and.w	r3, r3, #2
    533c:	2b00      	cmp	r3, #0
    533e:	d1e3      	bne.n	5308 <USBHwEPWrite+0x38>
        USBTxData = (pbBuf[3] << 24) | (pbBuf[2] << 16) | (pbBuf[1] << 8) | pbBuf[0];
        pbBuf += 4;
    }

    USBCtrl = 0;
    5340:	4b07      	ldr	r3, [pc, #28]	; (5360 <USBHwEPWrite+0x90>)
    5342:	2200      	movs	r2, #0
    5344:	601a      	str	r2, [r3, #0]

    // select endpoint and validate buffer
    USBHwCmd(CMD_EP_SELECT | idx);
    5346:	697b      	ldr	r3, [r7, #20]
    5348:	b2db      	uxtb	r3, r3
    534a:	4618      	mov	r0, r3
    534c:	f7ff fe4c 	bl	4fe8 <USBHwCmd>
    USBHwCmd(CMD_EP_VALIDATE_BUFFER);
    5350:	20fa      	movs	r0, #250	; 0xfa
    5352:	f7ff fe49 	bl	4fe8 <USBHwCmd>
    
    return iLen;
    5356:	687b      	ldr	r3, [r7, #4]
}
    5358:	4618      	mov	r0, r3
    535a:	3718      	adds	r7, #24
    535c:	46bd      	mov	sp, r7
    535e:	bd80      	pop	{r7, pc}
    5360:	5000c228 	.word	0x5000c228
    5364:	5000c224 	.word	0x5000c224
    5368:	5000c21c 	.word	0x5000c21c

0000536c <USBHwEPRead>:
            
    @return the number of bytes available in the EP (possibly more than iMaxLen),
    or <0 in case of error.
 */
int USBHwEPRead(U8 bEP, U8 *pbBuf, U32 iMaxLen)
{
    536c:	b580      	push	{r7, lr}
    536e:	b088      	sub	sp, #32
    5370:	af00      	add	r7, sp, #0
    5372:	4603      	mov	r3, r0
    5374:	60b9      	str	r1, [r7, #8]
    5376:	607a      	str	r2, [r7, #4]
    5378:	73fb      	strb	r3, [r7, #15]
    U32 i, idx;
    U32 dwData, dwLen;
    
    idx = EP2IDX(bEP);
    537a:	7bfb      	ldrb	r3, [r7, #15]
    537c:	f003 030f 	and.w	r3, r3, #15
    5380:	005b      	lsls	r3, r3, #1
    5382:	7bfa      	ldrb	r2, [r7, #15]
    5384:	09d2      	lsrs	r2, r2, #7
    5386:	b2d2      	uxtb	r2, r2
    5388:	4313      	orrs	r3, r2
    538a:	617b      	str	r3, [r7, #20]
    
    // set read enable bit for specific endpoint
    USBCtrl = RD_EN | ((bEP & 0xF) << 2);
    538c:	4a27      	ldr	r2, [pc, #156]	; (542c <USBHwEPRead+0xc0>)
    538e:	7bfb      	ldrb	r3, [r7, #15]
    5390:	f003 030f 	and.w	r3, r3, #15
    5394:	009b      	lsls	r3, r3, #2
    5396:	f043 0301 	orr.w	r3, r3, #1
    539a:	6013      	str	r3, [r2, #0]
    
    // wait for PKT_RDY
    do {
        dwLen = USBRxPLen;
    539c:	4b24      	ldr	r3, [pc, #144]	; (5430 <USBHwEPRead+0xc4>)
    539e:	681b      	ldr	r3, [r3, #0]
    53a0:	613b      	str	r3, [r7, #16]
    } while ((dwLen & PKT_RDY) == 0);
    53a2:	693b      	ldr	r3, [r7, #16]
    53a4:	f403 6300 	and.w	r3, r3, #2048	; 0x800
    53a8:	2b00      	cmp	r3, #0
    53aa:	d0f7      	beq.n	539c <USBHwEPRead+0x30>
    
    // packet valid?
    if ((dwLen & DV) == 0) {
    53ac:	693b      	ldr	r3, [r7, #16]
    53ae:	f403 6380 	and.w	r3, r3, #1024	; 0x400
    53b2:	2b00      	cmp	r3, #0
    53b4:	d102      	bne.n	53bc <USBHwEPRead+0x50>
        return -1;
    53b6:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    53ba:	e033      	b.n	5424 <USBHwEPRead+0xb8>
    }
    
    // get length
    dwLen &= PKT_LNGTH_MASK;
    53bc:	693b      	ldr	r3, [r7, #16]
    53be:	f3c3 0309 	ubfx	r3, r3, #0, #10
    53c2:	613b      	str	r3, [r7, #16]
    
    // get data
    dwData = 0;
    53c4:	2300      	movs	r3, #0
    53c6:	61bb      	str	r3, [r7, #24]
    for (i = 0; i < dwLen; i++) {
    53c8:	2300      	movs	r3, #0
    53ca:	61fb      	str	r3, [r7, #28]
    53cc:	e01a      	b.n	5404 <USBHwEPRead+0x98>
        if ((i % 4) == 0) {
    53ce:	69fb      	ldr	r3, [r7, #28]
    53d0:	f003 0303 	and.w	r3, r3, #3
    53d4:	2b00      	cmp	r3, #0
    53d6:	d102      	bne.n	53de <USBHwEPRead+0x72>
            dwData = USBRxData;
    53d8:	4b16      	ldr	r3, [pc, #88]	; (5434 <USBHwEPRead+0xc8>)
    53da:	681b      	ldr	r3, [r3, #0]
    53dc:	61bb      	str	r3, [r7, #24]
        }
        if ((pbBuf != NULL) && (i < iMaxLen)) {
    53de:	68bb      	ldr	r3, [r7, #8]
    53e0:	2b00      	cmp	r3, #0
    53e2:	d009      	beq.n	53f8 <USBHwEPRead+0x8c>
    53e4:	69fa      	ldr	r2, [r7, #28]
    53e6:	687b      	ldr	r3, [r7, #4]
    53e8:	429a      	cmp	r2, r3
    53ea:	d205      	bcs.n	53f8 <USBHwEPRead+0x8c>
            pbBuf[i] = dwData & 0xFF;
    53ec:	68ba      	ldr	r2, [r7, #8]
    53ee:	69fb      	ldr	r3, [r7, #28]
    53f0:	4413      	add	r3, r2
    53f2:	69ba      	ldr	r2, [r7, #24]
    53f4:	b2d2      	uxtb	r2, r2
    53f6:	701a      	strb	r2, [r3, #0]
        }
        dwData >>= 8;
    53f8:	69bb      	ldr	r3, [r7, #24]
    53fa:	0a1b      	lsrs	r3, r3, #8
    53fc:	61bb      	str	r3, [r7, #24]
    // get length
    dwLen &= PKT_LNGTH_MASK;
    
    // get data
    dwData = 0;
    for (i = 0; i < dwLen; i++) {
    53fe:	69fb      	ldr	r3, [r7, #28]
    5400:	3301      	adds	r3, #1
    5402:	61fb      	str	r3, [r7, #28]
    5404:	69fa      	ldr	r2, [r7, #28]
    5406:	693b      	ldr	r3, [r7, #16]
    5408:	429a      	cmp	r2, r3
    540a:	d3e0      	bcc.n	53ce <USBHwEPRead+0x62>
        }
        dwData >>= 8;
    }

    // make sure RD_EN is clear
    USBCtrl = 0;
    540c:	4b07      	ldr	r3, [pc, #28]	; (542c <USBHwEPRead+0xc0>)
    540e:	2200      	movs	r2, #0
    5410:	601a      	str	r2, [r3, #0]

    // select endpoint and clear buffer
    USBHwCmd(CMD_EP_SELECT | idx);
    5412:	697b      	ldr	r3, [r7, #20]
    5414:	b2db      	uxtb	r3, r3
    5416:	4618      	mov	r0, r3
    5418:	f7ff fde6 	bl	4fe8 <USBHwCmd>
    USBHwCmd(CMD_EP_CLEAR_BUFFER);
    541c:	20f2      	movs	r0, #242	; 0xf2
    541e:	f7ff fde3 	bl	4fe8 <USBHwCmd>
    
    return dwLen;
    5422:	693b      	ldr	r3, [r7, #16]
}
    5424:	4618      	mov	r0, r3
    5426:	3720      	adds	r7, #32
    5428:	46bd      	mov	sp, r7
    542a:	bd80      	pop	{r7, pc}
    542c:	5000c228 	.word	0x5000c228
    5430:	5000c220 	.word	0x5000c220
    5434:	5000c218 	.word	0x5000c218

00005438 <USBHwConfigDevice>:
    'configured' bit is set in the device status register.
        
    @param [in] fConfigured If TRUE, configure device, else unconfigure
 */
void USBHwConfigDevice(BOOL fConfigured)
{
    5438:	b580      	push	{r7, lr}
    543a:	b082      	sub	sp, #8
    543c:	af00      	add	r7, sp, #0
    543e:	6078      	str	r0, [r7, #4]
    // set configured bit
    USBHwCmdWrite(CMD_DEV_CONFIG, fConfigured ? CONF_DEVICE : 0);
    5440:	687b      	ldr	r3, [r7, #4]
    5442:	2b00      	cmp	r3, #0
    5444:	bf14      	ite	ne
    5446:	2301      	movne	r3, #1
    5448:	2300      	moveq	r3, #0
    544a:	b2db      	uxtb	r3, r3
    544c:	b29b      	uxth	r3, r3
    544e:	20d8      	movs	r0, #216	; 0xd8
    5450:	4619      	mov	r1, r3
    5452:	f7ff fde1 	bl	5018 <USBHwCmdWrite>
}
    5456:	3708      	adds	r7, #8
    5458:	46bd      	mov	sp, r7
    545a:	bd80      	pop	{r7, pc}

0000545c <USBHwISR>:
    @todo Get all 11 bits of frame number instead of just 8

    Endpoint interrupts are mapped to the slow interrupt
 */
void USBHwISR(void)
{
    545c:	b580      	push	{r7, lr}
    545e:	b086      	sub	sp, #24
    5460:	af00      	add	r7, sp, #0

// LED9 monitors total time in interrupt routine
DEBUG_LED_ON(9);

    // handle device interrupts
    dwStatus = USBDevIntSt;
    5462:	4b5b      	ldr	r3, [pc, #364]	; (55d0 <USBHwISR+0x174>)
    5464:	681b      	ldr	r3, [r3, #0]
    5466:	613b      	str	r3, [r7, #16]
    
    // frame interrupt
    if (dwStatus & FRAME) {
    5468:	693b      	ldr	r3, [r7, #16]
    546a:	f003 0301 	and.w	r3, r3, #1
    546e:	2b00      	cmp	r3, #0
    5470:	d010      	beq.n	5494 <USBHwISR+0x38>
        // clear int
        USBDevIntClr = FRAME;
    5472:	4b58      	ldr	r3, [pc, #352]	; (55d4 <USBHwISR+0x178>)
    5474:	2201      	movs	r2, #1
    5476:	601a      	str	r2, [r3, #0]
        // call handler
        if (_pfnFrameHandler != NULL) {
    5478:	4b57      	ldr	r3, [pc, #348]	; (55d8 <USBHwISR+0x17c>)
    547a:	681b      	ldr	r3, [r3, #0]
    547c:	2b00      	cmp	r3, #0
    547e:	d009      	beq.n	5494 <USBHwISR+0x38>
            wFrame = USBHwCmdRead(CMD_DEV_READ_CUR_FRAME_NR);
    5480:	20f5      	movs	r0, #245	; 0xf5
    5482:	f7ff fde3 	bl	504c <USBHwCmdRead>
    5486:	4603      	mov	r3, r0
    5488:	81fb      	strh	r3, [r7, #14]
            _pfnFrameHandler(wFrame);
    548a:	4b53      	ldr	r3, [pc, #332]	; (55d8 <USBHwISR+0x17c>)
    548c:	681b      	ldr	r3, [r3, #0]
    548e:	89fa      	ldrh	r2, [r7, #14]
    5490:	4610      	mov	r0, r2
    5492:	4798      	blx	r3
        }
    }
    
    // device status interrupt
    if (dwStatus & DEV_STAT) {
    5494:	693b      	ldr	r3, [r7, #16]
    5496:	f003 0308 	and.w	r3, r3, #8
    549a:	2b00      	cmp	r3, #0
    549c:	d02b      	beq.n	54f6 <USBHwISR+0x9a>
        /*  Clear DEV_STAT interrupt before reading DEV_STAT register.
            This prevents corrupted device status reads, see
            LPC2148 User manual revision 2, 25 july 2006.
        */
        USBDevIntClr = DEV_STAT;
    549e:	4b4d      	ldr	r3, [pc, #308]	; (55d4 <USBHwISR+0x178>)
    54a0:	2208      	movs	r2, #8
    54a2:	601a      	str	r2, [r3, #0]
        bDevStat = USBHwCmdRead(CMD_DEV_STATUS);
    54a4:	20fe      	movs	r0, #254	; 0xfe
    54a6:	f7ff fdd1 	bl	504c <USBHwCmdRead>
    54aa:	4603      	mov	r3, r0
    54ac:	737b      	strb	r3, [r7, #13]
        if (bDevStat & (CON_CH | SUS_CH | RST)) {
    54ae:	7b7b      	ldrb	r3, [r7, #13]
    54b0:	f003 031a 	and.w	r3, r3, #26
    54b4:	2b00      	cmp	r3, #0
    54b6:	d01e      	beq.n	54f6 <USBHwISR+0x9a>
            // convert device status into something HW independent
            bStat = ((bDevStat & CON) ? DEV_STATUS_CONNECT : 0) |
    54b8:	7b7b      	ldrb	r3, [r7, #13]
    54ba:	f003 0301 	and.w	r3, r3, #1
    54be:	2b00      	cmp	r3, #0
    54c0:	bf14      	ite	ne
    54c2:	2301      	movne	r3, #1
    54c4:	2300      	moveq	r3, #0
    54c6:	b2db      	uxtb	r3, r3
    54c8:	b2da      	uxtb	r2, r3
    54ca:	7b7b      	ldrb	r3, [r7, #13]
    54cc:	f003 0304 	and.w	r3, r3, #4
    54d0:	b2db      	uxtb	r3, r3
    54d2:	4313      	orrs	r3, r2
    54d4:	b2da      	uxtb	r2, r3
    54d6:	7b7b      	ldrb	r3, [r7, #13]
    54d8:	f003 0310 	and.w	r3, r3, #16
    54dc:	b2db      	uxtb	r3, r3
    54de:	4313      	orrs	r3, r2
    54e0:	b2db      	uxtb	r3, r3
    54e2:	733b      	strb	r3, [r7, #12]
                    ((bDevStat & SUS) ? DEV_STATUS_SUSPEND : 0) |
                    ((bDevStat & RST) ? DEV_STATUS_RESET : 0);
            // call handler
            if (_pfnDevIntHandler != NULL) {
    54e4:	4b3d      	ldr	r3, [pc, #244]	; (55dc <USBHwISR+0x180>)
    54e6:	681b      	ldr	r3, [r3, #0]
    54e8:	2b00      	cmp	r3, #0
    54ea:	d004      	beq.n	54f6 <USBHwISR+0x9a>
DEBUG_LED_ON(8);        
                _pfnDevIntHandler(bStat);
    54ec:	4b3b      	ldr	r3, [pc, #236]	; (55dc <USBHwISR+0x180>)
    54ee:	681b      	ldr	r3, [r3, #0]
    54f0:	7b3a      	ldrb	r2, [r7, #12]
    54f2:	4610      	mov	r0, r2
    54f4:	4798      	blx	r3
            }
        }
    }
    
    // endpoint interrupt
    if (dwStatus & EP_SLOW) {
    54f6:	693b      	ldr	r3, [r7, #16]
    54f8:	f003 0304 	and.w	r3, r3, #4
    54fc:	2b00      	cmp	r3, #0
    54fe:	d063      	beq.n	55c8 <USBHwISR+0x16c>
        // clear EP_SLOW
        USBDevIntClr = EP_SLOW;
    5500:	4b34      	ldr	r3, [pc, #208]	; (55d4 <USBHwISR+0x178>)
    5502:	2204      	movs	r2, #4
    5504:	601a      	str	r2, [r3, #0]
        // check all endpoints
        for (i = 0; i < 32; i++) {
    5506:	2300      	movs	r3, #0
    5508:	617b      	str	r3, [r7, #20]
    550a:	e05a      	b.n	55c2 <USBHwISR+0x166>
            dwIntBit = (1 << i);
    550c:	2201      	movs	r2, #1
    550e:	697b      	ldr	r3, [r7, #20]
    5510:	fa02 f303 	lsl.w	r3, r2, r3
    5514:	60bb      	str	r3, [r7, #8]
            if (USBEpIntSt & dwIntBit) {
    5516:	4b32      	ldr	r3, [pc, #200]	; (55e0 <USBHwISR+0x184>)
    5518:	681a      	ldr	r2, [r3, #0]
    551a:	68bb      	ldr	r3, [r7, #8]
    551c:	4013      	ands	r3, r2
    551e:	2b00      	cmp	r3, #0
    5520:	d04c      	beq.n	55bc <USBHwISR+0x160>
                // clear int (and retrieve status)
                USBEpIntClr = dwIntBit;
    5522:	4a30      	ldr	r2, [pc, #192]	; (55e4 <USBHwISR+0x188>)
    5524:	68bb      	ldr	r3, [r7, #8]
    5526:	6013      	str	r3, [r2, #0]
                Wait4DevInt(CDFULL);
    5528:	2020      	movs	r0, #32
    552a:	f7ff fd45 	bl	4fb8 <Wait4DevInt>
                bEPStat = USBCmdData;
    552e:	4b2e      	ldr	r3, [pc, #184]	; (55e8 <USBHwISR+0x18c>)
    5530:	681b      	ldr	r3, [r3, #0]
    5532:	71fb      	strb	r3, [r7, #7]
                // convert EP pipe stat into something HW independent
                bStat = ((bEPStat & EPSTAT_FE) ? EP_STATUS_DATA : 0) |
    5534:	79fb      	ldrb	r3, [r7, #7]
    5536:	f003 0301 	and.w	r3, r3, #1
    553a:	2b00      	cmp	r3, #0
    553c:	bf14      	ite	ne
    553e:	2301      	movne	r3, #1
    5540:	2300      	moveq	r3, #0
    5542:	b2db      	uxtb	r3, r3
    5544:	b2da      	uxtb	r2, r3
    5546:	79fb      	ldrb	r3, [r7, #7]
    5548:	f003 0302 	and.w	r3, r3, #2
    554c:	b2db      	uxtb	r3, r3
    554e:	4313      	orrs	r3, r2
    5550:	b2da      	uxtb	r2, r3
    5552:	79fb      	ldrb	r3, [r7, #7]
    5554:	f003 0304 	and.w	r3, r3, #4
    5558:	b2db      	uxtb	r3, r3
    555a:	4313      	orrs	r3, r2
    555c:	b2da      	uxtb	r2, r3
    555e:	79fb      	ldrb	r3, [r7, #7]
    5560:	f003 0310 	and.w	r3, r3, #16
    5564:	b2db      	uxtb	r3, r3
    5566:	4313      	orrs	r3, r2
    5568:	b2da      	uxtb	r2, r3
    556a:	79fb      	ldrb	r3, [r7, #7]
    556c:	f003 0308 	and.w	r3, r3, #8
    5570:	b2db      	uxtb	r3, r3
    5572:	4313      	orrs	r3, r2
    5574:	b2db      	uxtb	r3, r3
    5576:	733b      	strb	r3, [r7, #12]
                        ((bEPStat & EPSTAT_ST) ? EP_STATUS_STALLED : 0) |
                        ((bEPStat & EPSTAT_STP) ? EP_STATUS_SETUP : 0) |
                        ((bEPStat & EPSTAT_EPN) ? EP_STATUS_NACKED : 0) |
                        ((bEPStat & EPSTAT_PO) ? EP_STATUS_ERROR : 0);
                // call handler
                if (_apfnEPIntHandlers[i / 2] != NULL) {
    5578:	697b      	ldr	r3, [r7, #20]
    557a:	0fda      	lsrs	r2, r3, #31
    557c:	4413      	add	r3, r2
    557e:	105b      	asrs	r3, r3, #1
    5580:	461a      	mov	r2, r3
    5582:	4b1a      	ldr	r3, [pc, #104]	; (55ec <USBHwISR+0x190>)
    5584:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    5588:	2b00      	cmp	r3, #0
    558a:	d017      	beq.n	55bc <USBHwISR+0x160>
DEBUG_LED_ON(10);       
                    _apfnEPIntHandlers[i / 2](IDX2EP(i), bStat);
    558c:	697b      	ldr	r3, [r7, #20]
    558e:	0fda      	lsrs	r2, r3, #31
    5590:	4413      	add	r3, r2
    5592:	105b      	asrs	r3, r3, #1
    5594:	461a      	mov	r2, r3
    5596:	4b15      	ldr	r3, [pc, #84]	; (55ec <USBHwISR+0x190>)
    5598:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    559c:	697a      	ldr	r2, [r7, #20]
    559e:	01d2      	lsls	r2, r2, #7
    55a0:	b2d1      	uxtb	r1, r2
    55a2:	697a      	ldr	r2, [r7, #20]
    55a4:	1052      	asrs	r2, r2, #1
    55a6:	b2d2      	uxtb	r2, r2
    55a8:	f002 020f 	and.w	r2, r2, #15
    55ac:	b2d2      	uxtb	r2, r2
    55ae:	430a      	orrs	r2, r1
    55b0:	b2d2      	uxtb	r2, r2
    55b2:	b2d1      	uxtb	r1, r2
    55b4:	7b3a      	ldrb	r2, [r7, #12]
    55b6:	4608      	mov	r0, r1
    55b8:	4611      	mov	r1, r2
    55ba:	4798      	blx	r3
    // endpoint interrupt
    if (dwStatus & EP_SLOW) {
        // clear EP_SLOW
        USBDevIntClr = EP_SLOW;
        // check all endpoints
        for (i = 0; i < 32; i++) {
    55bc:	697b      	ldr	r3, [r7, #20]
    55be:	3301      	adds	r3, #1
    55c0:	617b      	str	r3, [r7, #20]
    55c2:	697b      	ldr	r3, [r7, #20]
    55c4:	2b1f      	cmp	r3, #31
    55c6:	dda1      	ble.n	550c <USBHwISR+0xb0>
            }
        }
    }
    
DEBUG_LED_OFF(9);       
}
    55c8:	3718      	adds	r7, #24
    55ca:	46bd      	mov	sp, r7
    55cc:	bd80      	pop	{r7, pc}
    55ce:	bf00      	nop
    55d0:	5000c200 	.word	0x5000c200
    55d4:	5000c208 	.word	0x5000c208
    55d8:	10000704 	.word	0x10000704
    55dc:	100006c0 	.word	0x100006c0
    55e0:	5000c230 	.word	0x5000c230
    55e4:	5000c238 	.word	0x5000c238
    55e8:	5000c214 	.word	0x5000c214
    55ec:	100006c4 	.word	0x100006c4

000055f0 <USBHwInit>:
    acts as a pull-up and so prevents detection of USB disconnect.
        
    @return TRUE if the hardware was successfully initialised
 */
BOOL USBHwInit(void)
{
    55f0:	b580      	push	{r7, lr}
    55f2:	af00      	add	r7, sp, #0
#ifdef LPC17xx
	// P2.9 is USB_CONNECT
    PINSEL4 = (PINSEL4 & ~(3 << 18)) | (1 << 18);
    55f4:	4a2d      	ldr	r2, [pc, #180]	; (56ac <USBHwInit+0xbc>)
    55f6:	4b2d      	ldr	r3, [pc, #180]	; (56ac <USBHwInit+0xbc>)
    55f8:	681b      	ldr	r3, [r3, #0]
    55fa:	f423 2340 	bic.w	r3, r3, #786432	; 0xc0000
    55fe:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
    5602:	6013      	str	r3, [r2, #0]

	// P1.18 is USB_UP_LED
    PINSEL3 = (PINSEL3 & ~(3 << 4)) | (1 << 4);
    5604:	4a2a      	ldr	r2, [pc, #168]	; (56b0 <USBHwInit+0xc0>)
    5606:	4b2a      	ldr	r3, [pc, #168]	; (56b0 <USBHwInit+0xc0>)
    5608:	681b      	ldr	r3, [r3, #0]
    560a:	f023 0330 	bic.w	r3, r3, #48	; 0x30
    560e:	f043 0310 	orr.w	r3, r3, #16
    5612:	6013      	str	r3, [r2, #0]

	// P1.30 is VBUS
    PINSEL3 = (PINSEL3 & ~(3 << 28)) | (2 << 28);
    5614:	4a26      	ldr	r2, [pc, #152]	; (56b0 <USBHwInit+0xc0>)
    5616:	4b26      	ldr	r3, [pc, #152]	; (56b0 <USBHwInit+0xc0>)
    5618:	681b      	ldr	r3, [r3, #0]
    561a:	f023 5340 	bic.w	r3, r3, #805306368	; 0x30000000
    561e:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
    5622:	6013      	str	r3, [r2, #0]

	// P0.29 is USB_D+
    PINSEL1 = (PINSEL1 & ~(3 << 26)) | (1 << 26);
    5624:	4a23      	ldr	r2, [pc, #140]	; (56b4 <USBHwInit+0xc4>)
    5626:	4b23      	ldr	r3, [pc, #140]	; (56b4 <USBHwInit+0xc4>)
    5628:	681b      	ldr	r3, [r3, #0]
    562a:	f023 6340 	bic.w	r3, r3, #201326592	; 0xc000000
    562e:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
    5632:	6013      	str	r3, [r2, #0]

	// P0.30 is USB_D-
    PINSEL1 = (PINSEL1 & ~(3 << 28)) | (1 << 28);
    5634:	4a1f      	ldr	r2, [pc, #124]	; (56b4 <USBHwInit+0xc4>)
    5636:	4b1f      	ldr	r3, [pc, #124]	; (56b4 <USBHwInit+0xc4>)
    5638:	681b      	ldr	r3, [r3, #0]
    563a:	f023 5340 	bic.w	r3, r3, #805306368	; 0x30000000
    563e:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
    5642:	6013      	str	r3, [r2, #0]

	// enable PUSB
	PCONP |= PCONP_PCUSB;
    5644:	4a1c      	ldr	r2, [pc, #112]	; (56b8 <USBHwInit+0xc8>)
    5646:	4b1c      	ldr	r3, [pc, #112]	; (56b8 <USBHwInit+0xc8>)
    5648:	681b      	ldr	r3, [r3, #0]
    564a:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
    564e:	6013      	str	r3, [r2, #0]

	/* enable the USB controller clocks */
    USBClkCtrl |= (USBClkCtrl_DEV_CLK_EN | USBClkCtrl_AHB_CLK_EN);
    5650:	4a1a      	ldr	r2, [pc, #104]	; (56bc <USBHwInit+0xcc>)
    5652:	4b1a      	ldr	r3, [pc, #104]	; (56bc <USBHwInit+0xcc>)
    5654:	681b      	ldr	r3, [r3, #0]
    5656:	f043 0312 	orr.w	r3, r3, #18
    565a:	6013      	str	r3, [r2, #0]
    while (!(USBClkSt & USBClkSt_DEV_CLK_ON));
    565c:	bf00      	nop
    565e:	4b18      	ldr	r3, [pc, #96]	; (56c0 <USBHwInit+0xd0>)
    5660:	681b      	ldr	r3, [r3, #0]
    5662:	f003 0302 	and.w	r3, r3, #2
    5666:	2b00      	cmp	r3, #0
    5668:	d0f9      	beq.n	565e <USBHwInit+0x6e>
    while (!(USBClkSt & USBClkSt_AHB_CLK_ON));
    566a:	bf00      	nop
    566c:	4b14      	ldr	r3, [pc, #80]	; (56c0 <USBHwInit+0xd0>)
    566e:	681b      	ldr	r3, [r3, #0]
    5670:	f003 0310 	and.w	r3, r3, #16
    5674:	2b00      	cmp	r3, #0
    5676:	d0f9      	beq.n	566c <USBHwInit+0x7c>
#endif

#endif
    
    // disable/clear all interrupts for now
    USBDevIntEn = 0;
    5678:	4b12      	ldr	r3, [pc, #72]	; (56c4 <USBHwInit+0xd4>)
    567a:	2200      	movs	r2, #0
    567c:	601a      	str	r2, [r3, #0]
    USBDevIntClr = 0xFFFFFFFF;
    567e:	4b12      	ldr	r3, [pc, #72]	; (56c8 <USBHwInit+0xd8>)
    5680:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    5684:	601a      	str	r2, [r3, #0]
    USBDevIntPri = 0;
    5686:	4b11      	ldr	r3, [pc, #68]	; (56cc <USBHwInit+0xdc>)
    5688:	2200      	movs	r2, #0
    568a:	601a      	str	r2, [r3, #0]

    USBEpIntEn = 0;
    568c:	4b10      	ldr	r3, [pc, #64]	; (56d0 <USBHwInit+0xe0>)
    568e:	2200      	movs	r2, #0
    5690:	601a      	str	r2, [r3, #0]
    USBEpIntClr = 0xFFFFFFFF;
    5692:	4b10      	ldr	r3, [pc, #64]	; (56d4 <USBHwInit+0xe4>)
    5694:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    5698:	601a      	str	r2, [r3, #0]
    USBEpIntPri = 0;
    569a:	4b0f      	ldr	r3, [pc, #60]	; (56d8 <USBHwInit+0xe8>)
    569c:	2200      	movs	r2, #0
    569e:	601a      	str	r2, [r3, #0]

    // by default, only ACKs generate interrupts
    USBHwNakIntEnable(0);
    56a0:	2000      	movs	r0, #0
    56a2:	f7ff fdcb 	bl	523c <USBHwNakIntEnable>
    // init debug leds
    DEBUG_LED_INIT(8);
    DEBUG_LED_INIT(9);
    DEBUG_LED_INIT(10);

    return TRUE;
    56a6:	2301      	movs	r3, #1
}
    56a8:	4618      	mov	r0, r3
    56aa:	bd80      	pop	{r7, pc}
    56ac:	4002c010 	.word	0x4002c010
    56b0:	4002c00c 	.word	0x4002c00c
    56b4:	4002c004 	.word	0x4002c004
    56b8:	400fc0c4 	.word	0x400fc0c4
    56bc:	5000cff4 	.word	0x5000cff4
    56c0:	5000cff8 	.word	0x5000cff8
    56c4:	5000c204 	.word	0x5000c204
    56c8:	5000c208 	.word	0x5000c208
    56cc:	5000c22c 	.word	0x5000c22c
    56d0:	5000c234 	.word	0x5000c234
    56d4:	5000c238 	.word	0x5000c238
    56d8:	5000c240 	.word	0x5000c240

000056dc <USBFilterOsVendorMessage>:
	@param [out]	*ppbData	Descriptor data
	
	@return TRUE if the request was handled by this filter, FALSE otherwise
 */
BOOL USBFilterOsVendorMessage(TSetupPacket *pSetup, BOOL *pfSuccess, int *piLen, U8 **ppbData)
{
    56dc:	b480      	push	{r7}
    56de:	b089      	sub	sp, #36	; 0x24
    56e0:	af00      	add	r7, sp, #0
    56e2:	60f8      	str	r0, [r7, #12]
    56e4:	60b9      	str	r1, [r7, #8]
    56e6:	607a      	str	r2, [r7, #4]
    56e8:	603b      	str	r3, [r7, #0]
	if(bMsVendorIndex == 0)	{
    56ea:	4b2d      	ldr	r3, [pc, #180]	; (57a0 <USBFilterOsVendorMessage+0xc4>)
    56ec:	781b      	ldrb	r3, [r3, #0]
    56ee:	2b00      	cmp	r3, #0
    56f0:	d101      	bne.n	56f6 <USBFilterOsVendorMessage+0x1a>
		// Feature is disabled.
		return FALSE;
    56f2:	2300      	movs	r3, #0
    56f4:	e04e      	b.n	5794 <USBFilterOsVendorMessage+0xb8>
	}
	
	if(pSetup->bRequest == bMsVendorIndex) {
    56f6:	68fb      	ldr	r3, [r7, #12]
    56f8:	785a      	ldrb	r2, [r3, #1]
    56fa:	4b29      	ldr	r3, [pc, #164]	; (57a0 <USBFilterOsVendorMessage+0xc4>)
    56fc:	781b      	ldrb	r3, [r3, #0]
    56fe:	429a      	cmp	r2, r3
    5700:	d147      	bne.n	5792 <USBFilterOsVendorMessage+0xb6>
		// Fail unless we make it to the end.
		*pfSuccess = FALSE;
    5702:	68bb      	ldr	r3, [r7, #8]
    5704:	2200      	movs	r2, #0
    5706:	601a      	str	r2, [r3, #0]
	
		int iRequestLength = pSetup->wLength;
    5708:	68fb      	ldr	r3, [r7, #12]
    570a:	88db      	ldrh	r3, [r3, #6]
    570c:	61fb      	str	r3, [r7, #28]
		U8 bInterfaceNumber = GET_OS_DESC_INTERFACE(pSetup->wValue);
    570e:	68fb      	ldr	r3, [r7, #12]
    5710:	885b      	ldrh	r3, [r3, #2]
    5712:	76fb      	strb	r3, [r7, #27]
		U8 bPageNumber = GET_OS_DESC_PAGE(pSetup->wValue);
    5714:	68fb      	ldr	r3, [r7, #12]
    5716:	885b      	ldrh	r3, [r3, #2]
    5718:	0a1b      	lsrs	r3, r3, #8
    571a:	b29b      	uxth	r3, r3
    571c:	76bb      	strb	r3, [r7, #26]
	
		switch (pSetup->wIndex) {
    571e:	68fb      	ldr	r3, [r7, #12]
    5720:	889b      	ldrh	r3, [r3, #4]
    5722:	2b04      	cmp	r3, #4
    5724:	d002      	beq.n	572c <USBFilterOsVendorMessage+0x50>
    5726:	2b05      	cmp	r3, #5
    5728:	d007      	beq.n	573a <USBFilterOsVendorMessage+0x5e>
    572a:	e00d      	b.n	5748 <USBFilterOsVendorMessage+0x6c>
		case DESC_EXT_OS_FEATURES:
			*ppbData = (U8*)abExtendedOsFeatureDescriptor;
    572c:	683b      	ldr	r3, [r7, #0]
    572e:	4a1d      	ldr	r2, [pc, #116]	; (57a4 <USBFilterOsVendorMessage+0xc8>)
    5730:	601a      	str	r2, [r3, #0]
			*piLen = sizeof(abExtendedOsFeatureDescriptor);
    5732:	687b      	ldr	r3, [r7, #4]
    5734:	2228      	movs	r2, #40	; 0x28
    5736:	601a      	str	r2, [r3, #0]
			break;
    5738:	e008      	b.n	574c <USBFilterOsVendorMessage+0x70>
			
		case DESC_EXT_OS_PROPERTIES:
			*ppbData = abExtendedPropertiesFeatureDescriptor;
    573a:	683b      	ldr	r3, [r7, #0]
    573c:	4a1a      	ldr	r2, [pc, #104]	; (57a8 <USBFilterOsVendorMessage+0xcc>)
    573e:	601a      	str	r2, [r3, #0]
			*piLen = sizeof(abExtendedPropertiesFeatureDescriptor);			
    5740:	687b      	ldr	r3, [r7, #4]
    5742:	2292      	movs	r2, #146	; 0x92
    5744:	601a      	str	r2, [r3, #0]
			break;
    5746:	e001      	b.n	574c <USBFilterOsVendorMessage+0x70>

		default:
			return TRUE;
    5748:	2301      	movs	r3, #1
    574a:	e023      	b.n	5794 <USBFilterOsVendorMessage+0xb8>
		}
		
		// Decide what portion of the descriptor to return.
		int iPageOffset = bPageNumber*0x10000; // This will probably always be zero...
    574c:	7ebb      	ldrb	r3, [r7, #26]
    574e:	041b      	lsls	r3, r3, #16
    5750:	617b      	str	r3, [r7, #20]
		if (*piLen < iPageOffset) {
    5752:	687b      	ldr	r3, [r7, #4]
    5754:	681a      	ldr	r2, [r3, #0]
    5756:	697b      	ldr	r3, [r7, #20]
    5758:	429a      	cmp	r2, r3
    575a:	da01      	bge.n	5760 <USBFilterOsVendorMessage+0x84>
			// Not enough data for the requested offset.
			return TRUE;
    575c:	2301      	movs	r3, #1
    575e:	e019      	b.n	5794 <USBFilterOsVendorMessage+0xb8>
		}
		*ppbData += iPageOffset;
    5760:	683b      	ldr	r3, [r7, #0]
    5762:	681a      	ldr	r2, [r3, #0]
    5764:	697b      	ldr	r3, [r7, #20]
    5766:	441a      	add	r2, r3
    5768:	683b      	ldr	r3, [r7, #0]
    576a:	601a      	str	r2, [r3, #0]
		*piLen -= iPageOffset;
    576c:	687b      	ldr	r3, [r7, #4]
    576e:	681a      	ldr	r2, [r3, #0]
    5770:	697b      	ldr	r3, [r7, #20]
    5772:	1ad2      	subs	r2, r2, r3
    5774:	687b      	ldr	r3, [r7, #4]
    5776:	601a      	str	r2, [r3, #0]
		
		if (*piLen > iRequestLength) {
    5778:	687b      	ldr	r3, [r7, #4]
    577a:	681a      	ldr	r2, [r3, #0]
    577c:	69fb      	ldr	r3, [r7, #28]
    577e:	429a      	cmp	r2, r3
    5780:	dd02      	ble.n	5788 <USBFilterOsVendorMessage+0xac>
			// Clip data longer than the requested length
			*piLen = iRequestLength;
    5782:	687b      	ldr	r3, [r7, #4]
    5784:	69fa      	ldr	r2, [r7, #28]
    5786:	601a      	str	r2, [r3, #0]
		}
	
		*pfSuccess = TRUE;
    5788:	68bb      	ldr	r3, [r7, #8]
    578a:	2201      	movs	r2, #1
    578c:	601a      	str	r2, [r3, #0]
		return TRUE;
    578e:	2301      	movs	r3, #1
    5790:	e000      	b.n	5794 <USBFilterOsVendorMessage+0xb8>
	}
	
	// These are not the requests you are looking for
	return FALSE;
    5792:	2300      	movs	r3, #0
}
    5794:	4618      	mov	r0, r3
    5796:	3724      	adds	r7, #36	; 0x24
    5798:	46bd      	mov	sp, r7
    579a:	f85d 7b04 	ldr.w	r7, [sp], #4
    579e:	4770      	bx	lr
    57a0:	10000714 	.word	0x10000714
    57a4:	00005df0 	.word	0x00005df0
    57a8:	10000468 	.word	0x10000468

000057ac <USBGetOsStringDescriptor>:
	@param [out]	*ppbData	Descriptor data
	
	@return TRUE if the descriptor was found, FALSE otherwise
 */
BOOL USBGetOsStringDescriptor(int *piLen, U8 **ppbData)
{
    57ac:	b480      	push	{r7}
    57ae:	b083      	sub	sp, #12
    57b0:	af00      	add	r7, sp, #0
    57b2:	6078      	str	r0, [r7, #4]
    57b4:	6039      	str	r1, [r7, #0]
	// The last character in the OS String descriptor specifies the vendor request index to use.
	abOsStringDescriptor[sizeof(abOsStringDescriptor)-2] = bMsVendorIndex;
    57b6:	4b08      	ldr	r3, [pc, #32]	; (57d8 <USBGetOsStringDescriptor+0x2c>)
    57b8:	781a      	ldrb	r2, [r3, #0]
    57ba:	4b08      	ldr	r3, [pc, #32]	; (57dc <USBGetOsStringDescriptor+0x30>)
    57bc:	741a      	strb	r2, [r3, #16]
	
	*ppbData = abOsStringDescriptor;
    57be:	683b      	ldr	r3, [r7, #0]
    57c0:	4a06      	ldr	r2, [pc, #24]	; (57dc <USBGetOsStringDescriptor+0x30>)
    57c2:	601a      	str	r2, [r3, #0]
	*piLen = sizeof(abOsStringDescriptor);
    57c4:	687b      	ldr	r3, [r7, #4]
    57c6:	2212      	movs	r2, #18
    57c8:	601a      	str	r2, [r3, #0]
	return TRUE;
    57ca:	2301      	movs	r3, #1
}
    57cc:	4618      	mov	r0, r3
    57ce:	370c      	adds	r7, #12
    57d0:	46bd      	mov	sp, r7
    57d2:	f85d 7b04 	ldr.w	r7, [sp], #4
    57d6:	4770      	bx	lr
    57d8:	10000714 	.word	0x10000714
    57dc:	10000454 	.word	0x10000454

000057e0 <USBRegisterDescriptors>:
	for the device.

	@param [in]	pabDescriptors	The descriptor byte array
 */
void USBRegisterDescriptors(const U8 *pabDescriptors)
{
    57e0:	b480      	push	{r7}
    57e2:	b083      	sub	sp, #12
    57e4:	af00      	add	r7, sp, #0
    57e6:	6078      	str	r0, [r7, #4]
	pabDescrip = pabDescriptors;
    57e8:	4a03      	ldr	r2, [pc, #12]	; (57f8 <USBRegisterDescriptors+0x18>)
    57ea:	687b      	ldr	r3, [r7, #4]
    57ec:	6013      	str	r3, [r2, #0]
}
    57ee:	370c      	adds	r7, #12
    57f0:	46bd      	mov	sp, r7
    57f2:	f85d 7b04 	ldr.w	r7, [sp], #4
    57f6:	4770      	bx	lr
    57f8:	10000710 	.word	0x10000710

000057fc <USBGetDescriptor>:
	@param [out]	*ppbData	Descriptor data
	
	@return TRUE if the descriptor was found, FALSE otherwise
 */
BOOL USBGetDescriptor(U16 wTypeIndex, U16 wLangID, int *piLen, U8 **ppbData)
{
    57fc:	b580      	push	{r7, lr}
    57fe:	b088      	sub	sp, #32
    5800:	af00      	add	r7, sp, #0
    5802:	60ba      	str	r2, [r7, #8]
    5804:	607b      	str	r3, [r7, #4]
    5806:	4603      	mov	r3, r0
    5808:	81fb      	strh	r3, [r7, #14]
    580a:	460b      	mov	r3, r1
    580c:	81bb      	strh	r3, [r7, #12]
	U8	*pab;
	int iCurIndex;
	
	ASSERT(pabDescrip != NULL);

	bType = GET_DESC_TYPE(wTypeIndex);
    580e:	89fb      	ldrh	r3, [r7, #14]
    5810:	0a1b      	lsrs	r3, r3, #8
    5812:	b29b      	uxth	r3, r3
    5814:	75fb      	strb	r3, [r7, #23]
	bIndex = GET_DESC_INDEX(wTypeIndex);
    5816:	89fb      	ldrh	r3, [r7, #14]
    5818:	75bb      	strb	r3, [r7, #22]
	
    if (bType == DESC_STRING &&
    581a:	7dfb      	ldrb	r3, [r7, #23]
    581c:	2b03      	cmp	r3, #3
    581e:	d10b      	bne.n	5838 <USBGetDescriptor+0x3c>
    5820:	7dbb      	ldrb	r3, [r7, #22]
    5822:	2bee      	cmp	r3, #238	; 0xee
    5824:	d108      	bne.n	5838 <USBGetDescriptor+0x3c>
        bIndex == DESC_STRING_OS) {
        
        if (USBGetOsStringDescriptor(piLen, ppbData)) {
    5826:	68b8      	ldr	r0, [r7, #8]
    5828:	6879      	ldr	r1, [r7, #4]
    582a:	f7ff ffbf 	bl	57ac <USBGetOsStringDescriptor>
    582e:	4603      	mov	r3, r0
    5830:	2b00      	cmp	r3, #0
    5832:	d001      	beq.n	5838 <USBGetDescriptor+0x3c>
            
            return TRUE;
    5834:	2301      	movs	r3, #1
    5836:	e036      	b.n	58a6 <USBGetDescriptor+0xaa>
        }
    }
    	
	
	pab = (U8 *)pabDescrip;
    5838:	4b1d      	ldr	r3, [pc, #116]	; (58b0 <USBGetDescriptor+0xb4>)
    583a:	681b      	ldr	r3, [r3, #0]
    583c:	61fb      	str	r3, [r7, #28]
	iCurIndex = 0;
    583e:	2300      	movs	r3, #0
    5840:	61bb      	str	r3, [r7, #24]
	
	while (pab[DESC_bLength] != 0) {
    5842:	e02b      	b.n	589c <USBGetDescriptor+0xa0>
		if (pab[DESC_bDescriptorType] == bType) {
    5844:	69fb      	ldr	r3, [r7, #28]
    5846:	3301      	adds	r3, #1
    5848:	781b      	ldrb	r3, [r3, #0]
    584a:	7dfa      	ldrb	r2, [r7, #23]
    584c:	429a      	cmp	r2, r3
    584e:	d11f      	bne.n	5890 <USBGetDescriptor+0x94>
			if (iCurIndex == bIndex) {
    5850:	7dba      	ldrb	r2, [r7, #22]
    5852:	69bb      	ldr	r3, [r7, #24]
    5854:	429a      	cmp	r2, r3
    5856:	d118      	bne.n	588a <USBGetDescriptor+0x8e>
				// set data pointer
				*ppbData = pab;
    5858:	687b      	ldr	r3, [r7, #4]
    585a:	69fa      	ldr	r2, [r7, #28]
    585c:	601a      	str	r2, [r3, #0]
				// get length from structure
				if (bType == DESC_CONFIGURATION) {
    585e:	7dfb      	ldrb	r3, [r7, #23]
    5860:	2b02      	cmp	r3, #2
    5862:	d10b      	bne.n	587c <USBGetDescriptor+0x80>
					// configuration descriptor is an exception, length is at offset 2 and 3
					*piLen =	(pab[CONF_DESC_wTotalLength]) |
    5864:	69fb      	ldr	r3, [r7, #28]
    5866:	3302      	adds	r3, #2
    5868:	781b      	ldrb	r3, [r3, #0]
    586a:	461a      	mov	r2, r3
								(pab[CONF_DESC_wTotalLength + 1] << 8);
    586c:	69fb      	ldr	r3, [r7, #28]
    586e:	3303      	adds	r3, #3
    5870:	781b      	ldrb	r3, [r3, #0]
    5872:	021b      	lsls	r3, r3, #8
				// set data pointer
				*ppbData = pab;
				// get length from structure
				if (bType == DESC_CONFIGURATION) {
					// configuration descriptor is an exception, length is at offset 2 and 3
					*piLen =	(pab[CONF_DESC_wTotalLength]) |
    5874:	431a      	orrs	r2, r3
    5876:	68bb      	ldr	r3, [r7, #8]
    5878:	601a      	str	r2, [r3, #0]
    587a:	e004      	b.n	5886 <USBGetDescriptor+0x8a>
								(pab[CONF_DESC_wTotalLength + 1] << 8);
				}
				else {
					// normally length is at offset 0
					*piLen = pab[DESC_bLength];
    587c:	69fb      	ldr	r3, [r7, #28]
    587e:	781b      	ldrb	r3, [r3, #0]
    5880:	461a      	mov	r2, r3
    5882:	68bb      	ldr	r3, [r7, #8]
    5884:	601a      	str	r2, [r3, #0]
				}
				return TRUE;
    5886:	2301      	movs	r3, #1
    5888:	e00d      	b.n	58a6 <USBGetDescriptor+0xaa>
			}
			iCurIndex++;
    588a:	69bb      	ldr	r3, [r7, #24]
    588c:	3301      	adds	r3, #1
    588e:	61bb      	str	r3, [r7, #24]
		}
		// skip to next descriptor
		pab += pab[DESC_bLength];
    5890:	69fb      	ldr	r3, [r7, #28]
    5892:	781b      	ldrb	r3, [r3, #0]
    5894:	461a      	mov	r2, r3
    5896:	69fb      	ldr	r3, [r7, #28]
    5898:	4413      	add	r3, r2
    589a:	61fb      	str	r3, [r7, #28]
    	
	
	pab = (U8 *)pabDescrip;
	iCurIndex = 0;
	
	while (pab[DESC_bLength] != 0) {
    589c:	69fb      	ldr	r3, [r7, #28]
    589e:	781b      	ldrb	r3, [r3, #0]
    58a0:	2b00      	cmp	r3, #0
    58a2:	d1cf      	bne.n	5844 <USBGetDescriptor+0x48>
		// skip to next descriptor
		pab += pab[DESC_bLength];
	}
	// nothing found
	DBG("Desc %x not found!\n", wTypeIndex);
	return FALSE;
    58a4:	2300      	movs	r3, #0
}
    58a6:	4618      	mov	r0, r3
    58a8:	3720      	adds	r7, #32
    58aa:	46bd      	mov	sp, r7
    58ac:	bd80      	pop	{r7, pc}
    58ae:	bf00      	nop
    58b0:	10000710 	.word	0x10000710

000058b4 <USBSetConfiguration>:
	@todo function always returns TRUE, add stricter checking?
	
	@return TRUE if successfully configured, FALSE otherwise
 */
static BOOL USBSetConfiguration(U8 bConfigIndex, U8 bAltSetting)
{
    58b4:	b580      	push	{r7, lr}
    58b6:	b086      	sub	sp, #24
    58b8:	af00      	add	r7, sp, #0
    58ba:	4603      	mov	r3, r0
    58bc:	460a      	mov	r2, r1
    58be:	71fb      	strb	r3, [r7, #7]
    58c0:	4613      	mov	r3, r2
    58c2:	71bb      	strb	r3, [r7, #6]
	U8	bEP;
	U16	wMaxPktSize;
	
	ASSERT(pabDescrip != NULL);

	if (bConfigIndex == 0) {
    58c4:	79fb      	ldrb	r3, [r7, #7]
    58c6:	2b00      	cmp	r3, #0
    58c8:	d103      	bne.n	58d2 <USBSetConfiguration+0x1e>
		// unconfigure device
		USBHwConfigDevice(FALSE);
    58ca:	2000      	movs	r0, #0
    58cc:	f7ff fdb4 	bl	5438 <USBHwConfigDevice>
    58d0:	e045      	b.n	595e <USBSetConfiguration+0xaa>
	}
	else {
		// configure endpoints for this configuration/altsetting
		pab = (U8 *)pabDescrip;
    58d2:	4b25      	ldr	r3, [pc, #148]	; (5968 <USBSetConfiguration+0xb4>)
    58d4:	681b      	ldr	r3, [r3, #0]
    58d6:	617b      	str	r3, [r7, #20]
		bCurConfig = 0xFF;
    58d8:	23ff      	movs	r3, #255	; 0xff
    58da:	74fb      	strb	r3, [r7, #19]
		bCurAltSetting = 0xFF;
    58dc:	23ff      	movs	r3, #255	; 0xff
    58de:	74bb      	strb	r3, [r7, #18]

		while (pab[DESC_bLength] != 0) {
    58e0:	e036      	b.n	5950 <USBSetConfiguration+0x9c>

			switch (pab[DESC_bDescriptorType]) {
    58e2:	697b      	ldr	r3, [r7, #20]
    58e4:	3301      	adds	r3, #1
    58e6:	781b      	ldrb	r3, [r3, #0]
    58e8:	2b04      	cmp	r3, #4
    58ea:	d008      	beq.n	58fe <USBSetConfiguration+0x4a>
    58ec:	2b05      	cmp	r3, #5
    58ee:	d00a      	beq.n	5906 <USBSetConfiguration+0x52>
    58f0:	2b02      	cmp	r3, #2
    58f2:	d000      	beq.n	58f6 <USBSetConfiguration+0x42>
					USBHwEPConfig(bEP, wMaxPktSize);
				}
				break;

			default:
				break;
    58f4:	e026      	b.n	5944 <USBSetConfiguration+0x90>

			switch (pab[DESC_bDescriptorType]) {

			case DESC_CONFIGURATION:
				// remember current configuration index
				bCurConfig = pab[CONF_DESC_bConfigurationValue];
    58f6:	697b      	ldr	r3, [r7, #20]
    58f8:	795b      	ldrb	r3, [r3, #5]
    58fa:	74fb      	strb	r3, [r7, #19]
				break;
    58fc:	e022      	b.n	5944 <USBSetConfiguration+0x90>

			case DESC_INTERFACE:
				// remember current alternate setting
				bCurAltSetting = pab[INTF_DESC_bAlternateSetting];
    58fe:	697b      	ldr	r3, [r7, #20]
    5900:	78db      	ldrb	r3, [r3, #3]
    5902:	74bb      	strb	r3, [r7, #18]
				break;
    5904:	e01e      	b.n	5944 <USBSetConfiguration+0x90>

			case DESC_ENDPOINT:
				if ((bCurConfig == bConfigIndex) &&
    5906:	7cfa      	ldrb	r2, [r7, #19]
    5908:	79fb      	ldrb	r3, [r7, #7]
    590a:	429a      	cmp	r2, r3
    590c:	d119      	bne.n	5942 <USBSetConfiguration+0x8e>
    590e:	7cba      	ldrb	r2, [r7, #18]
    5910:	79bb      	ldrb	r3, [r7, #6]
    5912:	429a      	cmp	r2, r3
    5914:	d115      	bne.n	5942 <USBSetConfiguration+0x8e>
					(bCurAltSetting == bAltSetting)) {
					// endpoint found for desired config and alternate setting
					bEP = pab[ENDP_DESC_bEndpointAddress];
    5916:	697b      	ldr	r3, [r7, #20]
    5918:	789b      	ldrb	r3, [r3, #2]
    591a:	747b      	strb	r3, [r7, #17]
					wMaxPktSize = 	(pab[ENDP_DESC_wMaxPacketSize]) |
    591c:	697b      	ldr	r3, [r7, #20]
    591e:	3304      	adds	r3, #4
    5920:	781b      	ldrb	r3, [r3, #0]
    5922:	b29a      	uxth	r2, r3
									(pab[ENDP_DESC_wMaxPacketSize + 1] << 8);
    5924:	697b      	ldr	r3, [r7, #20]
    5926:	3305      	adds	r3, #5
    5928:	781b      	ldrb	r3, [r3, #0]
    592a:	021b      	lsls	r3, r3, #8
			case DESC_ENDPOINT:
				if ((bCurConfig == bConfigIndex) &&
					(bCurAltSetting == bAltSetting)) {
					// endpoint found for desired config and alternate setting
					bEP = pab[ENDP_DESC_bEndpointAddress];
					wMaxPktSize = 	(pab[ENDP_DESC_wMaxPacketSize]) |
    592c:	b29b      	uxth	r3, r3
    592e:	4313      	orrs	r3, r2
    5930:	b29b      	uxth	r3, r3
    5932:	81fb      	strh	r3, [r7, #14]
									(pab[ENDP_DESC_wMaxPacketSize + 1] << 8);
					// configure endpoint
					USBHwEPConfig(bEP, wMaxPktSize);
    5934:	7c7a      	ldrb	r2, [r7, #17]
    5936:	89fb      	ldrh	r3, [r7, #14]
    5938:	4610      	mov	r0, r2
    593a:	4619      	mov	r1, r3
    593c:	f7ff fbde 	bl	50fc <USBHwEPConfig>
				}
				break;
    5940:	e7ff      	b.n	5942 <USBSetConfiguration+0x8e>
    5942:	bf00      	nop

			default:
				break;
			}
			// skip to next descriptor
			pab += pab[DESC_bLength];
    5944:	697b      	ldr	r3, [r7, #20]
    5946:	781b      	ldrb	r3, [r3, #0]
    5948:	461a      	mov	r2, r3
    594a:	697b      	ldr	r3, [r7, #20]
    594c:	4413      	add	r3, r2
    594e:	617b      	str	r3, [r7, #20]
		// configure endpoints for this configuration/altsetting
		pab = (U8 *)pabDescrip;
		bCurConfig = 0xFF;
		bCurAltSetting = 0xFF;

		while (pab[DESC_bLength] != 0) {
    5950:	697b      	ldr	r3, [r7, #20]
    5952:	781b      	ldrb	r3, [r3, #0]
    5954:	2b00      	cmp	r3, #0
    5956:	d1c4      	bne.n	58e2 <USBSetConfiguration+0x2e>
			// skip to next descriptor
			pab += pab[DESC_bLength];
		}
		
		// configure device
		USBHwConfigDevice(TRUE);
    5958:	2001      	movs	r0, #1
    595a:	f7ff fd6d 	bl	5438 <USBHwConfigDevice>
	}

	return TRUE;
    595e:	2301      	movs	r3, #1
}
    5960:	4618      	mov	r0, r3
    5962:	3718      	adds	r7, #24
    5964:	46bd      	mov	sp, r7
    5966:	bd80      	pop	{r7, pc}
    5968:	10000710 	.word	0x10000710

0000596c <HandleStdDeviceReq>:
	@param [in,out]	ppbData		Data buffer.

	@return TRUE if the request was handled successfully
 */
static BOOL HandleStdDeviceReq(TSetupPacket *pSetup, int *piLen, U8 **ppbData)
{
    596c:	b580      	push	{r7, lr}
    596e:	b086      	sub	sp, #24
    5970:	af00      	add	r7, sp, #0
    5972:	60f8      	str	r0, [r7, #12]
    5974:	60b9      	str	r1, [r7, #8]
    5976:	607a      	str	r2, [r7, #4]
	U8	*pbData = *ppbData;
    5978:	687b      	ldr	r3, [r7, #4]
    597a:	681b      	ldr	r3, [r3, #0]
    597c:	617b      	str	r3, [r7, #20]

	switch (pSetup->bRequest) {
    597e:	68fb      	ldr	r3, [r7, #12]
    5980:	785b      	ldrb	r3, [r3, #1]
    5982:	2b09      	cmp	r3, #9
    5984:	d852      	bhi.n	5a2c <HandleStdDeviceReq+0xc0>
    5986:	a201      	add	r2, pc, #4	; (adr r2, 598c <HandleStdDeviceReq+0x20>)
    5988:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    598c:	000059b5 	.word	0x000059b5
    5990:	00005a25 	.word	0x00005a25
    5994:	00005a2d 	.word	0x00005a2d
    5998:	00005a25 	.word	0x00005a25
    599c:	00005a2d 	.word	0x00005a2d
    59a0:	000059cb 	.word	0x000059cb
    59a4:	000059d9 	.word	0x000059d9
    59a8:	00005a29 	.word	0x00005a29
    59ac:	000059f1 	.word	0x000059f1
    59b0:	00005a01 	.word	0x00005a01
	
	case REQ_GET_STATUS:
		// bit 0: self-powered
		// bit 1: remote wakeup = not supported
		pbData[0] = 0;
    59b4:	697b      	ldr	r3, [r7, #20]
    59b6:	2200      	movs	r2, #0
    59b8:	701a      	strb	r2, [r3, #0]
		pbData[1] = 0;
    59ba:	697b      	ldr	r3, [r7, #20]
    59bc:	3301      	adds	r3, #1
    59be:	2200      	movs	r2, #0
    59c0:	701a      	strb	r2, [r3, #0]
		*piLen = 2;
    59c2:	68bb      	ldr	r3, [r7, #8]
    59c4:	2202      	movs	r2, #2
    59c6:	601a      	str	r2, [r3, #0]
		break;
    59c8:	e032      	b.n	5a30 <HandleStdDeviceReq+0xc4>
		
	case REQ_SET_ADDRESS:
		USBHwSetAddress(pSetup->wValue);
    59ca:	68fb      	ldr	r3, [r7, #12]
    59cc:	885b      	ldrh	r3, [r3, #2]
    59ce:	b2db      	uxtb	r3, r3
    59d0:	4618      	mov	r0, r3
    59d2:	f7ff fc0f 	bl	51f4 <USBHwSetAddress>
		break;
    59d6:	e02b      	b.n	5a30 <HandleStdDeviceReq+0xc4>

	case REQ_GET_DESCRIPTOR:
		DBG("D%x", pSetup->wValue);
		return USBGetDescriptor(pSetup->wValue, pSetup->wIndex, piLen, ppbData);
    59d8:	68fb      	ldr	r3, [r7, #12]
    59da:	885a      	ldrh	r2, [r3, #2]
    59dc:	68fb      	ldr	r3, [r7, #12]
    59de:	889b      	ldrh	r3, [r3, #4]
    59e0:	4610      	mov	r0, r2
    59e2:	4619      	mov	r1, r3
    59e4:	68ba      	ldr	r2, [r7, #8]
    59e6:	687b      	ldr	r3, [r7, #4]
    59e8:	f7ff ff08 	bl	57fc <USBGetDescriptor>
    59ec:	4603      	mov	r3, r0
    59ee:	e020      	b.n	5a32 <HandleStdDeviceReq+0xc6>

	case REQ_GET_CONFIGURATION:
		// indicate if we are configured
		pbData[0] = bConfiguration;
    59f0:	4b12      	ldr	r3, [pc, #72]	; (5a3c <HandleStdDeviceReq+0xd0>)
    59f2:	781a      	ldrb	r2, [r3, #0]
    59f4:	697b      	ldr	r3, [r7, #20]
    59f6:	701a      	strb	r2, [r3, #0]
		*piLen = 1;
    59f8:	68bb      	ldr	r3, [r7, #8]
    59fa:	2201      	movs	r2, #1
    59fc:	601a      	str	r2, [r3, #0]
		break;
    59fe:	e017      	b.n	5a30 <HandleStdDeviceReq+0xc4>

	case REQ_SET_CONFIGURATION:
		if (!USBSetConfiguration(pSetup->wValue & 0xFF, 0)) {
    5a00:	68fb      	ldr	r3, [r7, #12]
    5a02:	885b      	ldrh	r3, [r3, #2]
    5a04:	b2db      	uxtb	r3, r3
    5a06:	4618      	mov	r0, r3
    5a08:	2100      	movs	r1, #0
    5a0a:	f7ff ff53 	bl	58b4 <USBSetConfiguration>
    5a0e:	4603      	mov	r3, r0
    5a10:	2b00      	cmp	r3, #0
    5a12:	d101      	bne.n	5a18 <HandleStdDeviceReq+0xac>
			DBG("USBSetConfiguration failed!\n");
			return FALSE;
    5a14:	2300      	movs	r3, #0
    5a16:	e00c      	b.n	5a32 <HandleStdDeviceReq+0xc6>
		}
		// configuration successful, update current configuration
		bConfiguration = pSetup->wValue & 0xFF;	
    5a18:	68fb      	ldr	r3, [r7, #12]
    5a1a:	885b      	ldrh	r3, [r3, #2]
    5a1c:	b2da      	uxtb	r2, r3
    5a1e:	4b07      	ldr	r3, [pc, #28]	; (5a3c <HandleStdDeviceReq+0xd0>)
    5a20:	701a      	strb	r2, [r3, #0]
		break;
    5a22:	e005      	b.n	5a30 <HandleStdDeviceReq+0xc4>
			// put DEVICE_REMOTE_WAKEUP code here
		}
		if (pSetup->wValue == FEA_TEST_MODE) {
			// put TEST_MODE code here
		}
		return FALSE;
    5a24:	2300      	movs	r3, #0
    5a26:	e004      	b.n	5a32 <HandleStdDeviceReq+0xc6>

	case REQ_SET_DESCRIPTOR:
		DBG("Device req %d not implemented\n", pSetup->bRequest);
		return FALSE;
    5a28:	2300      	movs	r3, #0
    5a2a:	e002      	b.n	5a32 <HandleStdDeviceReq+0xc6>

	default:
		DBG("Illegal device req %d\n", pSetup->bRequest);
		return FALSE;
    5a2c:	2300      	movs	r3, #0
    5a2e:	e000      	b.n	5a32 <HandleStdDeviceReq+0xc6>
	}
	
	return TRUE;
    5a30:	2301      	movs	r3, #1
}
    5a32:	4618      	mov	r0, r3
    5a34:	3718      	adds	r7, #24
    5a36:	46bd      	mov	sp, r7
    5a38:	bd80      	pop	{r7, pc}
    5a3a:	bf00      	nop
    5a3c:	10000708 	.word	0x10000708

00005a40 <HandleStdInterfaceReq>:
	@param [in]		ppbData		Data buffer.

	@return TRUE if the request was handled successfully
 */
static BOOL HandleStdInterfaceReq(TSetupPacket	*pSetup, int *piLen, U8 **ppbData)
{
    5a40:	b480      	push	{r7}
    5a42:	b087      	sub	sp, #28
    5a44:	af00      	add	r7, sp, #0
    5a46:	60f8      	str	r0, [r7, #12]
    5a48:	60b9      	str	r1, [r7, #8]
    5a4a:	607a      	str	r2, [r7, #4]
	U8	*pbData = *ppbData;
    5a4c:	687b      	ldr	r3, [r7, #4]
    5a4e:	681b      	ldr	r3, [r3, #0]
    5a50:	617b      	str	r3, [r7, #20]

	switch (pSetup->bRequest) {
    5a52:	68fb      	ldr	r3, [r7, #12]
    5a54:	785b      	ldrb	r3, [r3, #1]
    5a56:	2b0b      	cmp	r3, #11
    5a58:	d838      	bhi.n	5acc <HandleStdInterfaceReq+0x8c>
    5a5a:	a201      	add	r2, pc, #4	; (adr r2, 5a60 <HandleStdInterfaceReq+0x20>)
    5a5c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    5a60:	00005a91 	.word	0x00005a91
    5a64:	00005aa7 	.word	0x00005aa7
    5a68:	00005acd 	.word	0x00005acd
    5a6c:	00005aa7 	.word	0x00005aa7
    5a70:	00005acd 	.word	0x00005acd
    5a74:	00005acd 	.word	0x00005acd
    5a78:	00005acd 	.word	0x00005acd
    5a7c:	00005acd 	.word	0x00005acd
    5a80:	00005acd 	.word	0x00005acd
    5a84:	00005acd 	.word	0x00005acd
    5a88:	00005aab 	.word	0x00005aab
    5a8c:	00005ab9 	.word	0x00005ab9

	case REQ_GET_STATUS:
		// no bits specified
		pbData[0] = 0;
    5a90:	697b      	ldr	r3, [r7, #20]
    5a92:	2200      	movs	r2, #0
    5a94:	701a      	strb	r2, [r3, #0]
		pbData[1] = 0;
    5a96:	697b      	ldr	r3, [r7, #20]
    5a98:	3301      	adds	r3, #1
    5a9a:	2200      	movs	r2, #0
    5a9c:	701a      	strb	r2, [r3, #0]
		*piLen = 2;
    5a9e:	68bb      	ldr	r3, [r7, #8]
    5aa0:	2202      	movs	r2, #2
    5aa2:	601a      	str	r2, [r3, #0]
		break;
    5aa4:	e014      	b.n	5ad0 <HandleStdInterfaceReq+0x90>

	case REQ_CLEAR_FEATURE:
	case REQ_SET_FEATURE:
		// not defined for interface
		return FALSE;
    5aa6:	2300      	movs	r3, #0
    5aa8:	e013      	b.n	5ad2 <HandleStdInterfaceReq+0x92>
	
	case REQ_GET_INTERFACE:	// TODO use bNumInterfaces
        // there is only one interface, return n-1 (= 0)
		pbData[0] = 0;
    5aaa:	697b      	ldr	r3, [r7, #20]
    5aac:	2200      	movs	r2, #0
    5aae:	701a      	strb	r2, [r3, #0]
		*piLen = 1;
    5ab0:	68bb      	ldr	r3, [r7, #8]
    5ab2:	2201      	movs	r2, #1
    5ab4:	601a      	str	r2, [r3, #0]
		break;
    5ab6:	e00b      	b.n	5ad0 <HandleStdInterfaceReq+0x90>
	
	case REQ_SET_INTERFACE:	// TODO use bNumInterfaces
		// there is only one interface (= 0)
		if (pSetup->wValue != 0) {
    5ab8:	68fb      	ldr	r3, [r7, #12]
    5aba:	885b      	ldrh	r3, [r3, #2]
    5abc:	2b00      	cmp	r3, #0
    5abe:	d001      	beq.n	5ac4 <HandleStdInterfaceReq+0x84>
			return FALSE;
    5ac0:	2300      	movs	r3, #0
    5ac2:	e006      	b.n	5ad2 <HandleStdInterfaceReq+0x92>
		}
		*piLen = 0;
    5ac4:	68bb      	ldr	r3, [r7, #8]
    5ac6:	2200      	movs	r2, #0
    5ac8:	601a      	str	r2, [r3, #0]
		break;
    5aca:	e001      	b.n	5ad0 <HandleStdInterfaceReq+0x90>

	default:
		DBG("Illegal interface req %d\n", pSetup->bRequest);
		return FALSE;
    5acc:	2300      	movs	r3, #0
    5ace:	e000      	b.n	5ad2 <HandleStdInterfaceReq+0x92>
	}

	return TRUE;
    5ad0:	2301      	movs	r3, #1
}
    5ad2:	4618      	mov	r0, r3
    5ad4:	371c      	adds	r7, #28
    5ad6:	46bd      	mov	sp, r7
    5ad8:	f85d 7b04 	ldr.w	r7, [sp], #4
    5adc:	4770      	bx	lr
    5ade:	bf00      	nop

00005ae0 <HandleStdEndPointReq>:
	@param [in]		ppbData		Data buffer.

	@return TRUE if the request was handled successfully
 */
static BOOL HandleStdEndPointReq(TSetupPacket	*pSetup, int *piLen, U8 **ppbData)
{
    5ae0:	b580      	push	{r7, lr}
    5ae2:	b086      	sub	sp, #24
    5ae4:	af00      	add	r7, sp, #0
    5ae6:	60f8      	str	r0, [r7, #12]
    5ae8:	60b9      	str	r1, [r7, #8]
    5aea:	607a      	str	r2, [r7, #4]
	U8	*pbData = *ppbData;
    5aec:	687b      	ldr	r3, [r7, #4]
    5aee:	681b      	ldr	r3, [r3, #0]
    5af0:	617b      	str	r3, [r7, #20]

	switch (pSetup->bRequest) {
    5af2:	68fb      	ldr	r3, [r7, #12]
    5af4:	785b      	ldrb	r3, [r3, #1]
    5af6:	2b0c      	cmp	r3, #12
    5af8:	d853      	bhi.n	5ba2 <HandleStdEndPointReq+0xc2>
    5afa:	a201      	add	r2, pc, #4	; (adr r2, 5b00 <HandleStdEndPointReq+0x20>)
    5afc:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    5b00:	00005b35 	.word	0x00005b35
    5b04:	00005b67 	.word	0x00005b67
    5b08:	00005ba3 	.word	0x00005ba3
    5b0c:	00005b83 	.word	0x00005b83
    5b10:	00005ba3 	.word	0x00005ba3
    5b14:	00005ba3 	.word	0x00005ba3
    5b18:	00005ba3 	.word	0x00005ba3
    5b1c:	00005ba3 	.word	0x00005ba3
    5b20:	00005ba3 	.word	0x00005ba3
    5b24:	00005ba3 	.word	0x00005ba3
    5b28:	00005ba3 	.word	0x00005ba3
    5b2c:	00005ba3 	.word	0x00005ba3
    5b30:	00005b9f 	.word	0x00005b9f
	case REQ_GET_STATUS:
		// bit 0 = endpointed halted or not
		pbData[0] = (USBHwEPGetStatus(pSetup->wIndex) & EP_STATUS_STALLED) ? 1 : 0;
    5b34:	68fb      	ldr	r3, [r7, #12]
    5b36:	889b      	ldrh	r3, [r3, #4]
    5b38:	b2db      	uxtb	r3, r3
    5b3a:	4618      	mov	r0, r3
    5b3c:	f7ff fb8c 	bl	5258 <USBHwEPGetStatus>
    5b40:	4603      	mov	r3, r0
    5b42:	f003 0302 	and.w	r3, r3, #2
    5b46:	2b00      	cmp	r3, #0
    5b48:	bf14      	ite	ne
    5b4a:	2301      	movne	r3, #1
    5b4c:	2300      	moveq	r3, #0
    5b4e:	b2db      	uxtb	r3, r3
    5b50:	461a      	mov	r2, r3
    5b52:	697b      	ldr	r3, [r7, #20]
    5b54:	701a      	strb	r2, [r3, #0]
		pbData[1] = 0;
    5b56:	697b      	ldr	r3, [r7, #20]
    5b58:	3301      	adds	r3, #1
    5b5a:	2200      	movs	r2, #0
    5b5c:	701a      	strb	r2, [r3, #0]
		*piLen = 2;
    5b5e:	68bb      	ldr	r3, [r7, #8]
    5b60:	2202      	movs	r2, #2
    5b62:	601a      	str	r2, [r3, #0]
		break;
    5b64:	e01f      	b.n	5ba6 <HandleStdEndPointReq+0xc6>
		
	case REQ_CLEAR_FEATURE:
		if (pSetup->wValue == FEA_ENDPOINT_HALT) {
    5b66:	68fb      	ldr	r3, [r7, #12]
    5b68:	885b      	ldrh	r3, [r3, #2]
    5b6a:	2b00      	cmp	r3, #0
    5b6c:	d107      	bne.n	5b7e <HandleStdEndPointReq+0x9e>
			// clear HALT by unstalling
			USBHwEPStall(pSetup->wIndex, FALSE);
    5b6e:	68fb      	ldr	r3, [r7, #12]
    5b70:	889b      	ldrh	r3, [r3, #4]
    5b72:	b2db      	uxtb	r3, r3
    5b74:	4618      	mov	r0, r3
    5b76:	2100      	movs	r1, #0
    5b78:	f7ff fb86 	bl	5288 <USBHwEPStall>
			break;
    5b7c:	e013      	b.n	5ba6 <HandleStdEndPointReq+0xc6>
		}
		// only ENDPOINT_HALT defined for endpoints
		return FALSE;
    5b7e:	2300      	movs	r3, #0
    5b80:	e012      	b.n	5ba8 <HandleStdEndPointReq+0xc8>
	
	case REQ_SET_FEATURE:
		if (pSetup->wValue == FEA_ENDPOINT_HALT) {
    5b82:	68fb      	ldr	r3, [r7, #12]
    5b84:	885b      	ldrh	r3, [r3, #2]
    5b86:	2b00      	cmp	r3, #0
    5b88:	d107      	bne.n	5b9a <HandleStdEndPointReq+0xba>
			// set HALT by stalling
			USBHwEPStall(pSetup->wIndex, TRUE);
    5b8a:	68fb      	ldr	r3, [r7, #12]
    5b8c:	889b      	ldrh	r3, [r3, #4]
    5b8e:	b2db      	uxtb	r3, r3
    5b90:	4618      	mov	r0, r3
    5b92:	2101      	movs	r1, #1
    5b94:	f7ff fb78 	bl	5288 <USBHwEPStall>
			break;
    5b98:	e005      	b.n	5ba6 <HandleStdEndPointReq+0xc6>
		}
		// only ENDPOINT_HALT defined for endpoints
		return FALSE;
    5b9a:	2300      	movs	r3, #0
    5b9c:	e004      	b.n	5ba8 <HandleStdEndPointReq+0xc8>

	case REQ_SYNCH_FRAME:
		DBG("EP req %d not implemented\n", pSetup->bRequest);
		return FALSE;
    5b9e:	2300      	movs	r3, #0
    5ba0:	e002      	b.n	5ba8 <HandleStdEndPointReq+0xc8>

	default:
		DBG("Illegal EP req %d\n", pSetup->bRequest);
		return FALSE;
    5ba2:	2300      	movs	r3, #0
    5ba4:	e000      	b.n	5ba8 <HandleStdEndPointReq+0xc8>
	}
	
	return TRUE;
    5ba6:	2301      	movs	r3, #1
}
    5ba8:	4618      	mov	r0, r3
    5baa:	3718      	adds	r7, #24
    5bac:	46bd      	mov	sp, r7
    5bae:	bd80      	pop	{r7, pc}

00005bb0 <USBHandleStandardRequest>:
	@param [in]		ppbData		Data buffer.

	@return TRUE if the request was handled successfully
 */
BOOL USBHandleStandardRequest(TSetupPacket	*pSetup, int *piLen, U8 **ppbData)
{
    5bb0:	b580      	push	{r7, lr}
    5bb2:	b084      	sub	sp, #16
    5bb4:	af00      	add	r7, sp, #0
    5bb6:	60f8      	str	r0, [r7, #12]
    5bb8:	60b9      	str	r1, [r7, #8]
    5bba:	607a      	str	r2, [r7, #4]
	// try the custom request handler first
	if ((pfnHandleCustomReq != NULL) && pfnHandleCustomReq(pSetup, piLen, ppbData)) {
    5bbc:	4b19      	ldr	r3, [pc, #100]	; (5c24 <USBHandleStandardRequest+0x74>)
    5bbe:	681b      	ldr	r3, [r3, #0]
    5bc0:	2b00      	cmp	r3, #0
    5bc2:	d00a      	beq.n	5bda <USBHandleStandardRequest+0x2a>
    5bc4:	4b17      	ldr	r3, [pc, #92]	; (5c24 <USBHandleStandardRequest+0x74>)
    5bc6:	681b      	ldr	r3, [r3, #0]
    5bc8:	68f8      	ldr	r0, [r7, #12]
    5bca:	68b9      	ldr	r1, [r7, #8]
    5bcc:	687a      	ldr	r2, [r7, #4]
    5bce:	4798      	blx	r3
    5bd0:	4603      	mov	r3, r0
    5bd2:	2b00      	cmp	r3, #0
    5bd4:	d001      	beq.n	5bda <USBHandleStandardRequest+0x2a>
		return TRUE;
    5bd6:	2301      	movs	r3, #1
    5bd8:	e01f      	b.n	5c1a <USBHandleStandardRequest+0x6a>
	}
	
	switch (REQTYPE_GET_RECIP(pSetup->bmRequestType)) {
    5bda:	68fb      	ldr	r3, [r7, #12]
    5bdc:	781b      	ldrb	r3, [r3, #0]
    5bde:	f003 031f 	and.w	r3, r3, #31
    5be2:	2b01      	cmp	r3, #1
    5be4:	d00a      	beq.n	5bfc <USBHandleStandardRequest+0x4c>
    5be6:	2b02      	cmp	r3, #2
    5be8:	d00f      	beq.n	5c0a <USBHandleStandardRequest+0x5a>
    5bea:	2b00      	cmp	r3, #0
    5bec:	d114      	bne.n	5c18 <USBHandleStandardRequest+0x68>
	case REQTYPE_RECIP_DEVICE:		return HandleStdDeviceReq(pSetup, piLen, ppbData);
    5bee:	68f8      	ldr	r0, [r7, #12]
    5bf0:	68b9      	ldr	r1, [r7, #8]
    5bf2:	687a      	ldr	r2, [r7, #4]
    5bf4:	f7ff feba 	bl	596c <HandleStdDeviceReq>
    5bf8:	4603      	mov	r3, r0
    5bfa:	e00e      	b.n	5c1a <USBHandleStandardRequest+0x6a>
	case REQTYPE_RECIP_INTERFACE:	return HandleStdInterfaceReq(pSetup, piLen, ppbData);
    5bfc:	68f8      	ldr	r0, [r7, #12]
    5bfe:	68b9      	ldr	r1, [r7, #8]
    5c00:	687a      	ldr	r2, [r7, #4]
    5c02:	f7ff ff1d 	bl	5a40 <HandleStdInterfaceReq>
    5c06:	4603      	mov	r3, r0
    5c08:	e007      	b.n	5c1a <USBHandleStandardRequest+0x6a>
	case REQTYPE_RECIP_ENDPOINT: 	return HandleStdEndPointReq(pSetup, piLen, ppbData);
    5c0a:	68f8      	ldr	r0, [r7, #12]
    5c0c:	68b9      	ldr	r1, [r7, #8]
    5c0e:	687a      	ldr	r2, [r7, #4]
    5c10:	f7ff ff66 	bl	5ae0 <HandleStdEndPointReq>
    5c14:	4603      	mov	r3, r0
    5c16:	e000      	b.n	5c1a <USBHandleStandardRequest+0x6a>
	default: 						return FALSE;
    5c18:	2300      	movs	r3, #0
	}
}
    5c1a:	4618      	mov	r0, r3
    5c1c:	3710      	adds	r7, #16
    5c1e:	46bd      	mov	sp, r7
    5c20:	bd80      	pop	{r7, pc}
    5c22:	bf00      	nop
    5c24:	1000070c 	.word	0x1000070c

00005c28 <memcpy>:
    5c28:	4684      	mov	ip, r0
    5c2a:	ea41 0300 	orr.w	r3, r1, r0
    5c2e:	f013 0303 	ands.w	r3, r3, #3
    5c32:	d149      	bne.n	5cc8 <memcpy+0xa0>
    5c34:	3a40      	subs	r2, #64	; 0x40
    5c36:	d323      	bcc.n	5c80 <memcpy+0x58>
    5c38:	680b      	ldr	r3, [r1, #0]
    5c3a:	6003      	str	r3, [r0, #0]
    5c3c:	684b      	ldr	r3, [r1, #4]
    5c3e:	6043      	str	r3, [r0, #4]
    5c40:	688b      	ldr	r3, [r1, #8]
    5c42:	6083      	str	r3, [r0, #8]
    5c44:	68cb      	ldr	r3, [r1, #12]
    5c46:	60c3      	str	r3, [r0, #12]
    5c48:	690b      	ldr	r3, [r1, #16]
    5c4a:	6103      	str	r3, [r0, #16]
    5c4c:	694b      	ldr	r3, [r1, #20]
    5c4e:	6143      	str	r3, [r0, #20]
    5c50:	698b      	ldr	r3, [r1, #24]
    5c52:	6183      	str	r3, [r0, #24]
    5c54:	69cb      	ldr	r3, [r1, #28]
    5c56:	61c3      	str	r3, [r0, #28]
    5c58:	6a0b      	ldr	r3, [r1, #32]
    5c5a:	6203      	str	r3, [r0, #32]
    5c5c:	6a4b      	ldr	r3, [r1, #36]	; 0x24
    5c5e:	6243      	str	r3, [r0, #36]	; 0x24
    5c60:	6a8b      	ldr	r3, [r1, #40]	; 0x28
    5c62:	6283      	str	r3, [r0, #40]	; 0x28
    5c64:	6acb      	ldr	r3, [r1, #44]	; 0x2c
    5c66:	62c3      	str	r3, [r0, #44]	; 0x2c
    5c68:	6b0b      	ldr	r3, [r1, #48]	; 0x30
    5c6a:	6303      	str	r3, [r0, #48]	; 0x30
    5c6c:	6b4b      	ldr	r3, [r1, #52]	; 0x34
    5c6e:	6343      	str	r3, [r0, #52]	; 0x34
    5c70:	6b8b      	ldr	r3, [r1, #56]	; 0x38
    5c72:	6383      	str	r3, [r0, #56]	; 0x38
    5c74:	6bcb      	ldr	r3, [r1, #60]	; 0x3c
    5c76:	63c3      	str	r3, [r0, #60]	; 0x3c
    5c78:	3040      	adds	r0, #64	; 0x40
    5c7a:	3140      	adds	r1, #64	; 0x40
    5c7c:	3a40      	subs	r2, #64	; 0x40
    5c7e:	d2db      	bcs.n	5c38 <memcpy+0x10>
    5c80:	3230      	adds	r2, #48	; 0x30
    5c82:	d30b      	bcc.n	5c9c <memcpy+0x74>
    5c84:	680b      	ldr	r3, [r1, #0]
    5c86:	6003      	str	r3, [r0, #0]
    5c88:	684b      	ldr	r3, [r1, #4]
    5c8a:	6043      	str	r3, [r0, #4]
    5c8c:	688b      	ldr	r3, [r1, #8]
    5c8e:	6083      	str	r3, [r0, #8]
    5c90:	68cb      	ldr	r3, [r1, #12]
    5c92:	60c3      	str	r3, [r0, #12]
    5c94:	3010      	adds	r0, #16
    5c96:	3110      	adds	r1, #16
    5c98:	3a10      	subs	r2, #16
    5c9a:	d2f3      	bcs.n	5c84 <memcpy+0x5c>
    5c9c:	320c      	adds	r2, #12
    5c9e:	d305      	bcc.n	5cac <memcpy+0x84>
    5ca0:	f851 3b04 	ldr.w	r3, [r1], #4
    5ca4:	f840 3b04 	str.w	r3, [r0], #4
    5ca8:	3a04      	subs	r2, #4
    5caa:	d2f9      	bcs.n	5ca0 <memcpy+0x78>
    5cac:	3204      	adds	r2, #4
    5cae:	d008      	beq.n	5cc2 <memcpy+0x9a>
    5cb0:	07d2      	lsls	r2, r2, #31
    5cb2:	bf1c      	itt	ne
    5cb4:	f811 3b01 	ldrbne.w	r3, [r1], #1
    5cb8:	f800 3b01 	strbne.w	r3, [r0], #1
    5cbc:	d301      	bcc.n	5cc2 <memcpy+0x9a>
    5cbe:	880b      	ldrh	r3, [r1, #0]
    5cc0:	8003      	strh	r3, [r0, #0]
    5cc2:	4660      	mov	r0, ip
    5cc4:	4770      	bx	lr
    5cc6:	bf00      	nop
    5cc8:	2a08      	cmp	r2, #8
    5cca:	d313      	bcc.n	5cf4 <memcpy+0xcc>
    5ccc:	078b      	lsls	r3, r1, #30
    5cce:	d0b1      	beq.n	5c34 <memcpy+0xc>
    5cd0:	f010 0303 	ands.w	r3, r0, #3
    5cd4:	d0ae      	beq.n	5c34 <memcpy+0xc>
    5cd6:	f1c3 0304 	rsb	r3, r3, #4
    5cda:	1ad2      	subs	r2, r2, r3
    5cdc:	07db      	lsls	r3, r3, #31
    5cde:	bf1c      	itt	ne
    5ce0:	f811 3b01 	ldrbne.w	r3, [r1], #1
    5ce4:	f800 3b01 	strbne.w	r3, [r0], #1
    5ce8:	d3a4      	bcc.n	5c34 <memcpy+0xc>
    5cea:	f831 3b02 	ldrh.w	r3, [r1], #2
    5cee:	f820 3b02 	strh.w	r3, [r0], #2
    5cf2:	e79f      	b.n	5c34 <memcpy+0xc>
    5cf4:	3a04      	subs	r2, #4
    5cf6:	d3d9      	bcc.n	5cac <memcpy+0x84>
    5cf8:	3a01      	subs	r2, #1
    5cfa:	f811 3b01 	ldrb.w	r3, [r1], #1
    5cfe:	f800 3b01 	strb.w	r3, [r0], #1
    5d02:	d2f9      	bcs.n	5cf8 <memcpy+0xd0>
    5d04:	780b      	ldrb	r3, [r1, #0]
    5d06:	7003      	strb	r3, [r0, #0]
    5d08:	784b      	ldrb	r3, [r1, #1]
    5d0a:	7043      	strb	r3, [r0, #1]
    5d0c:	788b      	ldrb	r3, [r1, #2]
    5d0e:	7083      	strb	r3, [r0, #2]
    5d10:	4660      	mov	r0, ip
    5d12:	4770      	bx	lr
    5d14:	00000043 	.word	0x00000043

00005d18 <_global_impure_ptr>:
    5d18:	10000020                                 ...

00005d1c <abDescriptors>:
    5d1c:	01010112 40000002 0005ffff 02010100     .......@........
    5d2c:	02090103 01020043 0932c000 01000004     ....C.....2.....
    5d3c:	00010202 10002405 01240501 24040101     .....$....$....$
    5d4c:	24050202 07010006 08038105 04090a00     ...$............
    5d5c:	0a020001 07000000 40020505 05070000     ...........@....
    5d6c:	00400282 09030400 68034404 74007400     ..@......D.h.t.t
    5d7c:	3a007000 2f002f00 62007500 72006500     .p.:././.u.b.e.r
    5d8c:	6f007400 74006f00 2e006800 6f007300     .t.o.o.t.h...s.o
    5d9c:	72007500 65006300 6f006600 67007200     .u.r.c.e.f.o.r.g
    5dac:	2e006500 65006e00 2f007400 55032200     .e...n.e.t./.".U
    5dbc:	65006200 74007200 6f006f00 68007400     .b.e.r.t.o.o.t.h
    5dcc:	73002000 72006500 61006900 12006c00     . .s.e.r.i.a.l..
    5ddc:	30003003 30003000 30003000 31003000     .0.0.0.0.0.0.0.1
    5dec:	00000000                                ....

00005df0 <abExtendedOsFeatureDescriptor>:
    5df0:	00000028 00040100 00000001 00000000     (...............
    5e00:	49570100 4253554e 00000000 00000000     ..WINUSB........
    5e10:	00000000 00000000                       ........

00005e18 <_init>:
    5e18:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    5e1a:	bf00      	nop
    5e1c:	bcf8      	pop	{r3, r4, r5, r6, r7}
    5e1e:	bc08      	pop	{r3}
    5e20:	469e      	mov	lr, r3
    5e22:	4770      	bx	lr

00005e24 <__init_array_start>:
    5e24:	0000429d 	.word	0x0000429d

00005e28 <__frame_dummy_init_array_entry>:
    5e28:	00004139                                9A..

00005e2c <_fini>:
    5e2c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    5e2e:	bf00      	nop
    5e30:	bcf8      	pop	{r3, r4, r5, r6, r7}
    5e32:	bc08      	pop	{r3}
    5e34:	469e      	mov	lr, r3
    5e36:	4770      	bx	lr

00005e38 <__fini_array_start>:
    5e38:	00004111 	.word	0x00004111

00005e3c <__fini_array_end>:
    5e3c:	00000000 	.word	0x00000000
